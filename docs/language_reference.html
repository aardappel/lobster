<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Lobster Language Reference</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="github.css" />
  <link rel="icon" type="image/svg" href="lobster.svg" />
</head>
<body>
<header id="title-block-header">
<h1 class="title">Lobster Language Reference</h1>
</header>
<p>This is the definition of the language that tries to be a more exact
a description of how the language works (the most exact description,
however, will always be the source code :) ). As such, this is not the
easiest way to learn the language, start with a tutorial first, and then
use this for more difficult questions.</p>
<p>Syntactically Lobster tries to follow a mix of Python and C
conventions where possible, but has a lot of unique syntax too.</p>
<h2 id="lexical-definition">Lexical definition</h2>
<ul>
<li><p>Whitespace is space, tab, carriage return, nested comments
delimited by <code>/*</code> and <code>*/</code> or single line comments
starting with <code>//</code></p></li>
<li><p>Operator tokens are
<code>( ) [ ] { } : , &amp; | + ++ += - -- -= * *= / /= % %= ==     != &lt; &gt; &lt;= &gt;= &lt;- = ? . -&gt; ^ &lt;&lt; &gt;&gt;</code></p></li>
<li><p>Strings delimited by <code>"</code> and character constants with
<code>'</code> using escape codes <code>\n \t \r \" \' \ \x</code>
(followed by 2 hex digits, e.g. <code>\xFF</code> is the character with
value 255). Alternatively, strings can be enclosed in triple-quotes
(<code>"""</code>) and may then contain any characters verbatim,
including new-lines, quotes, and escape codes (which are all left
untouched).</p></li>
<li><p>Numbers consisting of a series of digits to indicate an integer
constant (e.g. <code>123</code>) or hex digits with a leading
<code>0x</code> (e.g. <code>0xABADCAFE</code>) or digits with a single
<code>.</code> (e.g. <code>.1</code> or <code>1.</code> or
<code>1.1</code>) to indicate a floating point constant.</p></li>
<li><p>Identifiers made from alpha-numeric characters and the
<code>_</code> (except no digits for the first character).</p></li>
<li><p>Keywords:
<code>nil return class struct import int float string any void     def fn is from program private resource enum enum_flags typeof     var let pakfile switch case default namespace not and or attribute     if for while super constructor guard abstract member member_frame     static static_frame attribute operator</code></p></li>
<li><p>Linefeed is whitespace if it follows a token that indicates an
incomplete expression (such as <code>+</code> or <code>,</code>) and an
actual token otherwise (used to separate lists of expressions inside a
block, see below).</p></li>
<li><p><code>indent</code> and <code>dedent</code> tokens are generated
whenever the indentation level changes. Indentation of any 2 adjacent
lines must start with the same sequence of spaces and/or tabs. This
ensures it is impossible to create indentation that behaves differently
from the way it looks visually.</p></li>
</ul>
<h2 id="grammar">Grammar</h2>
<p>Below, <code>...</code> indicates a loop with exit point at that
scope level (ex. <code>(ident ... ,)</code> -&gt;
<code>(ident (, ident)*)</code>, * meaning optionaly repeating), and
<code>||</code> is like <code>|</code> except indicates a precedence
level difference. <code>[rule]</code> Means optional.</p>
<p>program = stats end_of_file</p>
<p>stats = topexp … linefeed</p>
<p>topexp = <code>namespace</code> ident |<code>import</code> [
<code>from</code> ] ( string_constant | ( ident ... <code>.</code> ) ) |
[ <code>private</code> ] ( functiondef | class | vardef | enumdef ) |
expstat | attrdef</p>
<p>class = ( <code>class</code> | <code>struct</code> ) ident (
<code>=</code> ident specializers | [ generics ] <code>:</code> [ ident
[ specializers ] ] indlist( ident [ <code>:</code> type ] [
<code>=</code> exp ] | functiondef ) )</p>
<p>specializers = <code>&lt;</code> list( type ) <code>&gt;</code></p>
<p>generics = <code>&lt;</code> list( ident ) <code>&gt;</code></p>
<p>vardef = ( <code>var</code> | <code>let</code> ) list( ident [
<code>:</code> type ] ) <code>=</code> opexp</p>
<p>enumdef = ( <code>enum</code> | <code>enum_flags</code> ) ident
<code>:</code> indlist( ident [ <code>=</code> integer_constant ] )</p>
<p>functiondef = ( <code>def</code> | <code>constructor</code> ) ident [
generics ] functionargsbody</p>
<p>functionargsbody = <code>(</code> args <code>)</code> <code>:</code>
body</p>
<p>block = [ args ] <code>:</code> body | functionargsbody</p>
<p>args = [ list( ident [ ( <code>:</code> | <code>::</code> ) type ] [
<code>=</code> exp ] ) ]</p>
<p>body = ( expstat | indent stats dedent )</p>
<p>type = <code>int</code> | <code>float</code> | <code>string</code> |
<code>[</code> type <code>]</code> | <code>resource</code>
<code>&lt;</code> ident <code>&gt;</code> | <code>void</code> | ident [
specializers ]</p>
<p>call = [ specializers ] <code>(</code> [ list( exp ) ] <code>)</code>
[ block [ <code>fn</code> block … ] ]</p>
<p>expstat = exp | <code>return</code> ( [ list( opexp ) ] ) [
<code>from</code> ( <code>program</code> | ident ) ]</p>
<p>exp = opexp [ ( <code>=</code> | <code>+=</code> | <code>-=</code> |
<code>*=</code> | <code>/=</code> | <code>%=</code> ) exp ]</p>
<p>opexp = unary [ ( <code>*</code> | <code>/</code> | <code>%</code> ||
<code>+</code> | <code>-</code> || <code>&lt;</code> | <code>&gt;</code>
| <code>&gt;=</code> | <code>&lt;=</code> || <code>==</code> |
<code>!=</code> || <code>&amp;</code> | <code>|</code> |
<code>and</code> | <code>or</code> | ^ | <code>&lt;&lt;</code> |
<code>&gt;&gt;</code>) unary ]</p>
<p>unary = ( <code>-</code> | <code>++</code> | <code>--</code> | ~ |
<code>not</code> ) unary | deref</p>
<p>deref = factor [ <code>[</code> exp <code>]</code> | <code>.</code>
ident [ call ] | <code>-&gt;</code> ident | <code>++</code> |
<code>--</code> | <code>is</code> type ]</p>
<p>factor = constant | <code>(</code> exp <code>)</code> |
<code>super</code> | ctrlflow | pakfile string_constant | constructor |
<code>fn</code> functionargsbody | ident [ call ]</p>
<p>ctrlflow = <code>if</code> ifpart | (<code>for</code> |
<code>while</code>) exp <code>:</code> body | <code>guard</code> exp [
<code>:</code> body ]</p>
<p>ifpart = exp <code>:</code> body (<code>else</code> <code>:</code>
body | <code>elif</code> <code>:</code> ifpart)</p>
<p>constructor = <code>[</code> [ list( exp ) ] <code>]</code> [
<code>::</code> type ] | ident <code>{</code> [ list( ident
<code>:</code> exp | exp ] <code>}</code></p>
<p>constant = numeric_constant | string_constant | character_constant |
<code>nil</code> [ <code>::</code> type ]</p>
<p>attrdef = <code>attribute</code> ident [ <code>=</code> (
string_constant | numeric_constant | ident ) ]</p>
<p>indlist(e) = indent list(e) [ linefeed ] dedent linefeed</p>
<p>list(e) = e ... <code>,</code></p>
<h2 id="types">Types</h2>
<p>Lobster is statically typed, and any variable, argument or vector
element can be a value of one of the following types:</p>
<ul>
<li><p>Scalar types (64-bit on all platforms):</p>
<ul>
<li><p><code>int</code> : a signed integer. Constructed using:</p>
<ul>
<li><p>integer constants : <code>123</code></p></li>
<li><p>hexadecimal constants : <code>0xABADCAFE</code></p></li>
<li><p>character constants : <code>'A'</code> (65)</p></li>
<li><p>default boolean values <code>true</code> and <code>false</code>
(same as <code>1</code> and <code>0</code>)</p></li>
</ul></li>
<li><p><code>float</code> : an IEEE floating point number</p></li>
<li><p>a function value, can be called just like normal functions. See
below.</p></li>
</ul></li>
<li><p>Reference values:</p>
<ul>
<li><p><code>string</code> : a vector of byte sized elements, generally
used to store text, but can store any byte array. The recommended format
for text is UTF-8, though this is not enforced; indexing and size
operations act on bytes. To properly manipulate unicode symbols, UTF-8
strings can be converted to vectors of uncompressed unicode values using
the built-in functions string_to_unicode and unicode_to_string.
Immutable: can be indexed into for reading but not writing.</p></li>
<li><p>vector : a dynamically sized array of any Lobster values,
constructed with square brackets surrounding 0 or more comma separated
values, e.g. <code>[ 1, 2, 3 ]</code> for which the element type is also
surrounded in square brackets, e.g. <code>[int]</code>. May be
dereferenced for reading/writing using indices (e.g. <code>a[0]</code>).
Vectors may be typed by being suffixed by <code>::type</code>, which
will require all elements to be of that type (also useful to force a
type on an empty list).</p></li>
<li><p><code>class</code> / <code>struct</code> : a user defined data
structure, see below.</p></li>
<li><p><code>nil</code> : a special value of any reference type above,
that indicates the absence of a legal value. <code>nil</code> is only
allowed if the type is "nilable", for more on that see the document on
type checking, <a href="type_checker.html">here</a>. Since just
<code>nil</code> doesn't make it obvious what type you are referring to,
you can use e.g. <code>nil::string</code> to specify a value of type
<code>string?</code> (a type that denotes the value can be a string or
nil), though in most cases type inference makes writing just
<code>nil</code> sufficient.</p></li>
<li><p><code>resource&lt;T&gt;</code> : an opaque object managed by the
engine / C++ code. <code>T</code> is the type, e.g. <code>texture</code>
or <code>mesh</code>, the availability of these depends on what engine
functionality is linked in to Lobster, see
<code>builtin_functions_reference.html</code> for what functions create
and use these resources. Their lifetime is managed by the language much
like other reference types above.</p></li>
</ul></li>
</ul>
<p>Lobster does not have a built-in boolean type, though it does have a
pre-defined <code>bool</code> enum (see enums below). In general, for
boolean tests such as the <code>not and or</code> operators (see below)
or the builtin function <code>if</code>, the values
<code>0 0.0 nil</code> (which includes the enum value
<code>false</code>) are all considered to be false, and all other values
are true.</p>
<p>The vector and <code>class</code> types are the only mutable objects
(can change after creation), and have reference semantics (multiple
values can refer to the same object in memory, and thus changes can be
observed from each).</p>
<h2 id="user-defined-types">User Defined Types</h2>
<p>The <code>class</code> and <code>struct</code> keywords allow you to
define a user defined type. For example:</p>
<pre><code>struct int2:
    x:int
    y:int

struct int3 : int2
    z:int</code></pre>
<p>You can use either <code>class</code> or <code>struct</code> to
define these, with the latter being more restrictive: they are stored
in-inline in their parent and copied. This makes sense for small objects
such as the one in this example.</p>
<p>You specify a list of fields using indentation.</p>
<p>Optionally, you specify a supertype, which has the effect of adding
all the fields of the supertype to the current type, thus making it an
extension of the former.</p>
<p>The above example uses ints directly, but you can also define types
more generically, and then define named specializations of them:</p>
<pre><code>struct vec2&lt;T&gt;:
    x:T
    y:T

struct int2 = vec2&lt;int&gt;
struct float2 = vec2&lt;float&gt;</code></pre>
<p>You construct values of these types you use a similar syntax:</p>
<pre><code>let v = int2 { 1, 0 }</code></pre>
<p>(Or use <code>float2 { 1, 0 }</code> /
<code>vec2&lt;bool&gt; { true, false }</code> to explicitly pick a
different specialization).</p>
<pre><code>struct float2:
    x = 0.0
    y = 0.0</code></pre>
<p>Additionally, you may specify default values, if these are given,
then these values are not arguments to the constructor, e.g.
<code>vec2 {}</code>.</p>
<p>For more complex structs, you can use field names as "tags" in a
constructor call, for example:</p>
<pre><code>vec2 { x: 1, y: 2 }</code></pre>
<p>Besides being more readable, it allows you to specify the fields in
any order, and to override fields that have defaults.</p>
<p>For more complex ways of constructing types, see constructor
functions below.</p>
<p>To declare a type whose only purpose is to serve as a superclass for
other types and is not to be instantiated, declare it with
<code>abstract</code>:</p>
<pre><code>abstract class Node</code></pre>
<h2 id="operators">Operators</h2>
<p>Lobster comes with a set of built-in operators mostly familiar from
other languages that attempt to work on as many of the above types as
makes sense. In particular, unlike most languages, many of them work on
(numeric) structs, which makes typical game code both convenient and
fast.</p>
<h3 id="assignment-and-definition">Assignment and Definition</h3>
<p>The assignment operators simply copies the value on the right hand
side into the variable or vector index on the left hand side:</p>
<pre><code>a = 1
v[0] = 1
v.x = 1</code></pre>
<p>All variables must already have been declared, or this will result in
an error. <code>var</code> defines and assigns in one go, and requires
the variable to not have been declared yet in this scope.
<code>let</code> does the same for variables which cannot be modified
afterwards:</p>
<pre><code>var a = 1
let b = 1</code></pre>
<pre><code>var d, e = 1, 2</code></pre>
<p>As you can see in the last 2 lines, all of these operators also allow
multiple values to be assigned at once (see also multiple return values
below).</p>
<h3 id="indexing">Indexing</h3>
<p>As indicated, square brackets can be used to index into vectors, and
similarly <code>.</code> can dereference fields of a <code>class</code>
or <code>struct</code>. These may be chained arbitrarily.</p>
<p>You may even use a vector as index, e.g.</p>
<pre><code>let mat = [ [ 1, 2 ],  [ 3, 4 ] ]
let pos = int2 { 0, 1 }
print mat[pos]</code></pre>
<p>This prints <code>3</code>, and is a convenient shortcut for
<code>mat[pos.y][pos.x]</code>. Note how it uses the last element to
index with first, this is because in code and other places 2d arrays are
usually most naturally thought of as row-major.</p>
<h3 id="mathematical-operators">Mathematical Operators</h3>
<p>The 5 binary mathematical operators <code>+ - * / %</code> (the last
3 having higher precedence) work on <code>int</code>, <code>float</code>
(or a combination, where the end result will be <code>float</code>).
They also work on structs containing ints or floats with either another
struct or a single int or float. These structs must be the same
type.</p>
<pre><code>int2 { 1, 2 } * int2 { 4, 5 }  // results in int2 { 4, 10 }</code></pre>
<p>All 5 also have have a combined assignment operator version,
<code>+= -= *= /= %=</code>, which are implemented to have exactly the
same effect as their expanded form, e.g. <code>a += 1</code> is always
exactly the same as <code>a = a + 1</code>.</p>
<p>In addition, the <code>+</code> operator also works as string
concatenation if either side is of string type (the other side will be
converted to a string representation if it wasn't already), though in
most cases you should prefer to use string interpolation (see
below).</p>
<p>Unary minus (<code>-</code>) acts on the same types in the same way
as the binary version.</p>
<p>The increment and decrement operators <code>++</code> and
<code>--</code> work either as prefix (increment, return new value) and
as postfix (increment, return old value) on any lvalues.</p>
<p>Bitwise operators <code>&amp; | ^ ~ &lt;&lt; &gt;&gt;</code> behave
like they do in any other language.</p>
<h3 id="comparison-and-logical-operators">Comparison and Logical
Operators</h3>
<p>The next lower level of precedence are the comparison operators
<code>&lt; &gt; &lt;= &gt;=</code> which work on <code>int</code>,
<code>float</code> and <code>string</code> and structs (returning a
struct of ints, use builtin functions <code>any</code> and
<code>all</code> to test these), and then the equality operators
<code>==</code> and <code>!=</code> which additionally work on all other
types, but in particular for <code>vector</code> and <code>class</code>
compare <em>by reference</em>, i.e they will give true only if both
sides refer to the same object (<em>object identity</em>). To test for
<em>structural identity</em> instead, use the built-in function
<code>equal</code>.</p>
<p>The logical operators <code>and</code> and <code>or</code> are the
next lower level of precedence, and both short-circuit:
<code>a or b</code> returns <code>a</code> if it is not a false value
(one of <code>0 0.0 nil</code>), and <code>b</code> otherwise.
<code>a and b</code> returns <code>a</code> if it is a false value,
<code>b</code> otherwise. The unary operator <code>not</code> turns
false values into <code>1</code> and others into <code>0</code>.</p>
<p>The <code>is</code> operator returns true if the left hand side value
is of the type specified on the right, e.g. <code>x is float</code>.</p>
<h2 id="function-definitions">Function Definitions</h2>
<p>Lobster's entire design centers around functions and how they can be
composed. It has both <em>named functions</em> and <em>function
values</em>.</p>
<h3 id="named-functions">Named Functions</h3>
<p>Named functions can be declared at any scope level (may be local),
like so:</p>
<pre><code>def name(arg1, arg2): body</code></pre>
<p><code>body</code> can either be a single expression, or, most
commonly, an indentation (start of code on the next line further than
the previous line, in this case the <code>def</code> keyword), and then
any number of expressions on their own line separated by linefeeds,
until a de-dedentation occurs (return to the indentation level of the
parent, in this case again the <code>def</code> keyword). It is an error
to de-dedent less than the parent level. For example:</p>
<pre><code>def name(arg1, arg2):
    exp1
    exp2</code></pre>
<p>The return value of a function is determined by its
<code>return</code> statements (see below) or <code>void</code> (no
return value) otherwise, except for anonymous functions, which don't
need an explicit <code>return</code> (it is automatically the last
expression evaluated).</p>
<p>Arguments can be just an argument name (which will be available as a
lexically scoped local variable inside body), or a typed name (e.g.
<code>s:string</code>). If you don't specify types, the function is
generic, meaning it will receive types from the caller. If called with
multiple combinations of incompatible arguments, you automatically get
multiple "specializations" of the same function, meaning working with
different types is very easy. Alternatively, you can specify generic
types explicitly as well (more in <a href="type_checker.html">type
system</a>).</p>
<p>You can use :: instead of : for typed class/struct arguments, which
allows you to access all fields / functions of that object directly,
without having to prefix them with the argument name, e.g.:</p>
<pre><code>def magnitude(v::vec2): return sqrt(x * x + y * y)</code></pre>
<p>You can also leave out the <code>v::vec2</code> entirely if you
define this function as part of a <code>class</code> /
<code>struct</code> definition of type <code>vec2</code> (see above).
Both types of definition are equivalent.</p>
<p>You can specify an explicit return type, like so:</p>
<pre><code>def f(a:int, b:int) -&gt; float: return a + b</code></pre>
<p>This is typically not necessary, but may be helpful when coercing to
a more general type.</p>
<h3 id="function-calls">Function calls</h3>
<p>Functions can be called as part of an expression with a similar
syntax to its definition, e.g. <code>name(1, 2)</code>. Alternatively,
you may use the <code>.</code> notation to place the first argument
ahead of the call, for example <code>1.name(2)</code>. If you are using
the <code>.</code> notation with a function that has just one argument,
the <code>()</code> may be omitted, <code>v.length</code> being a common
example. You are encouraged to only do this for simple functions that
return a property of the argument, and don't modify the argument.</p>
<p>Optionally, you may also call functions without any parentheses at
all, e.g. <code>print "hi!"</code>. This is only allowed for known
functions (that are not ambiguous with variables) that have 1 expression
argument (followed by any number of function value arguments that don't
take arguments themselves, see below). It is up to the programmer to use
good judgement on when to use this, the recommended use case is for
calls used as statements (no nesting) that don't cause additional
parentheses to be needed elsewhere. In case of doubt, use the standard
call syntax.</p>
<h3 id="function-values">Function Values</h3>
<p>You can also create anonymous (nameless) functions as values. In the
most general case, this has the syntax:</p>
<pre><code>let f = fn(a:type, n:type): body</code></pre>
<p>Or, if you are not specifying any types:</p>
<pre><code>let f = fn a, b: body</code></pre>
<p>You call these just like any other function, e.g.
<code>f(1, 2)</code>. You currently must call them using a variable (not
any expression, not even a field).</p>
<p>The full <code>fn</code> syntax is infrequently used however, because
most function values are created to be passed to other functions, and
Lobster has a special syntax for this situation that is meant to mimic
control structures in other languages. Any function call may be followed
by one or more function values, where the <code>fn</code> keyword is
omitted:</p>
<pre><code>g(10) i: print(i)</code></pre>
<p>Here, the function <code>g</code> is called with 2 arguments, the
first is <code>10</code>, and the second is the function value
<code>fn i: print(i)</code> (as before, we left out the the
<code>()</code> around the arguments). Lobster allows yet further
simplification of the syntax:</p>
<pre><code>g(10): print(_)
g 10: print _</code></pre>
<p>You may use anonymous arguments, which are variable names starting
with an <code>_</code> that will automatically be declared as arguments
for you. If you use multiple such arguments (e.g. <code>_a</code> and
<code>_b</code>), they will become arguments in the order they appear in
the body. Using anonymous variables is only recommended for very simple
function bodies.</p>
<p>As mentioned above, you may drop the parentheses entirely if the body
doesn't have any argument declarations.</p>
<p>This style of syntax is intended to make each function that takes a
function as argument (a <em>higher order function</em>) have the
convenient syntax of a control structure, since that's what those
functions usually are meant to be anyway. Lobster's built-in control
structures <code>if</code> <code>for</code> and <code>while</code> have
syntax that is closely compatible with this function call syntax (and in
the case of <code>for</code> allow the same argument
simplifications).</p>
<p>The return value of these functions is the last expression in
<code>body</code>. You don't use explicit <code>return</code>
statements, as those are used with the enclosing named function instead,
see "Explicit Returns" below.</p>
<p>Though not recommend (as readability suffers), it is even possible to
pass multiple function values to a function, but then every function
value except the first can't omit the <code>fn</code> keyword:</p>
<pre><code>g(10) i:
    print i
fn:
    print &quot;reached the end&quot;</code></pre>
<p>For example, to pass an additional function to do something special
at the end of an iteration.</p>
<p>Writing your own functions that take function values is the key to
getting the most out of Lobster. It allows you to refactor pretty much
any code into something that has no redundancy yet is easy to create,
use and modify.</p>
<p>Typically, to write a function that takes a function value argument,
simply use an argument with no type:</p>
<pre><code>def twice(f):
    for(2): f()</code></pre>
<p>Sometimes, you may want to be explicit about the function type. You
can declare new function types, and then use them as a type:</p>
<pre><code>def function_type(i:int) -&gt; int
def g(f:function_type): return 1 + f(2)</code></pre>
<p>Besides enforcing the type of function that can be passed (which
makes for more readable errors when it fails), it also forces the
function passed to not be inlined (which may reduce code-bloat if
functions taking this function type are called many times, at a minimal
hit in speed). Function values called over a generic variable are always
inlined (since they represent a unique function type even if its
signature is accidentally the same as another function value), to ensure
higher order functions are competitive in speed with hard-coded
equivalents.</p>
<p>Lobster really wants you to be able to use function values everywhere
at no cost, so besides guaranteed inlining, the other way they differ
from other languages is that they are always <em>non-escaping</em>. What
that means is, that while function values may use free variables (refer
to variables from enclosing scopes), they are not "closures", i.e. they
do not close over (capture) these variables, they merely refer to them.
This means these function values cannot be called from an environment
where those free variables are not available anymore (this will
typically result in a compile-time error). This makes a function value
in Lobster a single code pointer without any variable information
attached, and thus extremely cheap. The downside is that they can't be
used for things like certain kinds of callbacks, though you probably
shouldn't be using those in game-like contexts anyway ;)</p>
<h3 id="explicit-returns">Explicit Returns</h3>
<p>Using <code>return</code> you return from the closest lexically
enclosing named function, e.g.:</p>
<pre><code>def find(list, x):
    for list:
        if x == _:
            return true
    return false</code></pre>
<p><code>find</code>'s return value is <code>false</code> unless the
nested <code>return</code> gets evaluated, and then it becomes
<code>true</code>. Importantly, <code>return true</code> is an
expression that sits inside a function value being passed to
<code>if</code> (which in turn sits in a function value passed to
<code>for</code>), but bypasses all of this (unlike most programming
languages with function values). This is essential for functions to be
able to work as proper control structures.</p>
<p>If this feels like it is similar to exception handling in other
programming languages, that's because it is. Lobster even allows you to
specify the name of the function to return from (e.g.
<code>return "expression expected" from parse</code>), which is
extremely handy when you want to be able to return errors from a bunch
of helper functions without having to pass it back through all
intermediate functions, such as when writing a parser. This is a simple
form of exception handling, that is also powerful enough to allow you to
implement fully general exception handling in Lobster code, see
<code>exception.lobster</code>.</p>
<p>You can use the keyword <code>program</code> instead of a function
name to force returning from the entire program.</p>
<p>If you need to return from a function value with an explicit return,
you need to turn that particular function into a named function
instead.</p>
<h3 id="multiple-return-values">Multiple Return Values</h3>
<p>return can specify more than one value to be returned, which can then
be received by the multiple assignment syntax introduced above:</p>
<pre><code>def m(): return 1, 2
let a, b = m()</code></pre>
<p>All return statements for any function must all return the same
number of return values.</p>
<p>When <code>m</code> returns multiple values, they get assigned to
each variable in turn. If there are more return values than there are
variables, additionally values are thrown away, and if there are more
variables than there are return values, this is an error.</p>
<p>Other than functions (and in assignments statements, see above),
expressions can return multiple values in other contexts too, but there
may need to be placed in parentheses to disambiguate them from other
uses of <code>,</code>:</p>
<pre><code>let x, y = if foo: m() else: (1, 2)</code></pre>
<h3 id="scope">Scope</h3>
<p>Functions and variables declared there-in always obey lexical scope:
any use of a variable always refers to the closest enclosing definition
of it.</p>
<p>Since functions and function values can be defined at any scope
level, this means they can access variables from enclosing scopes,
called <em>free variables</em>. Free variables are essential to make
Lobster's higher order functions convenient. References to free
variables are only valid within the scope they are defined, which
luckily is almost always the case, but can be broken by storing a
function value and then calling it at a later time outside of the
context where its free variables were valid, which will result in a
runtime error. Other languages use <em>closures</em> to ensure
availability in all cases, which are very costly (parent stackframe(s)
may have to be dynamically allocated) as opposed to Lobster's approach
which makes function values and free variables have no overhead compared
to regular functions and variables.</p>
<h3 id="overloading-and-dynamic-dispatch">Overloading and dynamic
dispatch</h3>
<p>Overloading and dynamic dispatch are part of the same system, the
only difference being wether choosing the right function is done at
compile time or runtime.</p>
<p>You can define these overloads anywhere, either as part of a class,
or outside of them, regardless of wether you wrote the original class.
For example:</p>
<pre><code>def f(a::A): return 1
def f(b::B): return 2
def f(c::C): return 3
def f(i:int): return 4</code></pre>
<p>(as we note above, using <code>::</code> instead of <code>:</code>
merely means all fields of that type become directly available, saving
you having to type <code>a.</code>, but is otherwise equivalent.)</p>
<p>What happens when you call <code>f</code> depends on the types above,
and the type you call it with. If all 4 types are unrelated, then you
guaranteed get static dispatch (a normal function call). If
<code>B</code> inherits from <code>A</code>, but <code>C</code> is
unrelated, and you call with either a <code>B</code>, <code>C</code> or
<code>int</code> argument type, you still get static dispatch, since
there is statically only one option.</p>
<p>Only if you call with an <code>A</code> argument however, you get
dynamic dispatch, since the argument may point to a <code>B</code>
value, and <code>B</code> has a different function implementation. A
dynamic dispatch goes thru a "virtual table", and while slower than
static dispatch, is still very fast. As you can see, wether something is
"virtual" gets decided per call, and with knowledge of the whole program
(all types and functions that can possibly exist), so typically less
calls result in dynamic dispatch than in other languages.</p>
<p>Types like <code>int</code> never participate in dynamic dispatch,
since they don't have a sub-class relation to any other type.</p>
<p>Defining these functions can also be done "in line" in a class
declaration, like so:</p>
<pre><code>class A:
    def f(): return 1</code></pre>
<p>This definition of <code>f</code> for <code>A</code> is entirely
equivalent to the one above, except the name of the first argument is
now <code>this</code> instead of <code>a</code> above.</p>
<p>Only the first argument to a function is used to resolve dynamic
dispatch, but for static overloading, all arguments will be taken into
consideration. Lobster used to have the ability to dispatch on all
arguments, called "multi-methods", which at least academically seem very
elegant. In practice however, these are slow (require complicated
look-up tables) and ambiguous (hard to tell which function will get
called, sometimes accidentally combine unrelated functions into a
multimethod and get unexpected errors or slow-down). Single dispatch
gives predictable, fast polymorphism that seems to work well for most
languages, so for the moment, multi-methods are removed from the
language.</p>
<p>Overloading and dynamic dispatch can even be mixed with type
specialization (see <a href="type_checker.html">type system</a>),
meaning you can generate multiple versions of a polymorphic call that do
different things. Simply leave out the type of any arguments beyond the
first:</p>
<pre><code>class A:
    def g(c): return c + 1
class B : A
    def g(c): return c + 2
x : A = B {}  // Type is A, but dynamic value is a B!
assert x.g(&quot;hi&quot;) == &quot;hi2&quot;
assert x.g(3) == 5</code></pre>
<p>Here, the call to <code>g</code> is dynamically dispatched for
<code>A</code> or <code>B</code>, but choosing the <code>int</code> or
<code>string</code> specialization is entirely static.</p>
<p>You can force calling a superclass method with the <code>super</code>
keyword:</p>
<pre><code>class B : A
    def f(): return 1 + super f()</code></pre>
<p>That <code>f()</code> is statically dispatched to call
<code>A</code>'s version of <code>f</code> (or its superclass, if it
doesn't have one).</p>
<p>You can also "dynamic dispatch" with <code>switch</code> ! You can
use class names as switch cases:</p>
<pre><code>switch x:
    case A: print x.field_in_a
    case B: print x.field_in_b</code></pre>
<p>As you can see, the type of variable switched on will be "upgraded"
to the type matched, so you can access its fields.</p>
<p>switches on types are "exhaustive", meaning if you don't use a
<code>default</code> case (and its a good habit to not use those) you
will get a compile-time error if a type is not covered by a switch (all
possible subclasses of the type of the switched on value).</p>
<p>Superclass cases can apply to subclass cases, and if both are
present, the most specific case will always be used. It is a good idea
to make superclasses <code>abstract</code> for use with
<code>switch</code>, that way you may omit a case for them, causing all
their subclasses to need their own case.</p>
<p>The actual implementation use vtables much like the above dynamic
dispatch, so is similar in speed too.</p>
<h3
id="functions-with-different-number-of-arguments-default-arguments.">Functions
with different number of arguments / default arguments.</h3>
<p>You can define functions with the same name but different number of
arguments. These are essentially treated as independent functions, in
the sense that which is being called is always determined completely
statically.</p>
<p>Functions can even have default arguments, as long as the default
arguments don't cause ambiguity with other functions of the same
name:</p>
<pre><code>def da(a:X, b, c = x + 1): return c
def da(a:Y, b, c = x + 1): return c
def da(a): return a</code></pre>
<p>This defines 2 complete separate functions, one that has 3 arguments
(and can be called with 2, since it has one default argument), and one
with 1 argument. As you can see, since there is no overlap in number of
arguments, it is always clear which variant is being called.</p>
<p>The version with 3 arguments has 2 overloads. Overloads must have
exactly the same default arguments, if any.</p>
<p>Default arguments are simple substitution, writing
<code>da(1, 2)</code> is exactly the same as writing
<code>da(1, 2, x + 1)</code>. That's why you can even use variables in
these default arguments, as long as they're in scope when called.</p>
<h3 id="operator-overloading.">Operator overloading.</h3>
<p>You can overload what operators do on <code>class</code> and
<code>struct</code> types, by writing a function that defines what the
<code>operator</code> should do:</p>
<pre><code>struct A:
    x:int
    def operator+(o:A): return A { x + o.x }
    def operator-(): return A { -x }

print - A { 2 } + A { 3 }  // A { 1 }</code></pre>
<p>You may currently overload: <code>+</code> <code>-</code>
<code>*</code> <code>/</code> <code>%</code> <code>++</code>
<code>--</code> <code>==</code> <code>!=</code> <code>&lt;</code>
<code>&gt;</code> <code>&lt;=</code> <code>&gt;=</code>
<code>&amp;</code> <code>|</code> <code>^</code> <code>~</code>
<code>&lt;&lt;</code> <code>&gt;&gt;</code> <code>=</code>
<code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code>
<code>%=</code> <code>&amp;=</code> <code>|=</code> <code>^=</code>
<code>&lt;&lt;=</code> <code>&gt;&gt;=</code> <code>[]</code>
(indexing).</p>
<p>Overloaded operators are parsed with the same operator precedence as
for the built-in operators, but when it comes to typechecking, they are
handled as regular function calls, with all that entails. The above
expression is thus handled internally as
<code>operator+(operator-(A { 2 }), A { 3 })</code> where
<code>operator+</code> is just an ordinary function name.</p>
<p>The assignment operators make most sense to overload on
<code>class</code> types, since there you can overwrite the members of
the <code>this</code> (or left) argument of the operator. There is
currently no way to do this with <code>struct</code> which are always
copied by value.</p>
<p>See more examples in <code>modules/quaternion.lobster</code> and
<code>tests/operators.lobster</code>.</p>
<h3 id="global-and-class-member-variables-with-function-scope.">Global
and Class member variables with function scope.</h3>
<p>You may declare a (what appears to be) a local variable with the
<code>member</code> keyword instead of <code>let</code>, which
automatically stores it in the surrounding class:</p>
<pre><code>class Foo:
    a = 1
    def bar():
        member b = 2
        b += a
        return b</code></pre>
<p>Calling <code>bar</code> will give different results each time, it
really is almost the same as writing:</p>
<pre><code>class Foo:
    a = 1
    b = 2
    def bar():
        b += a
        return b</code></pre>
<p>The difference is that <code>b</code> is not available outside of
<code>bar</code>, trying to access it will result in an error.</p>
<p>But why would you want to do this, if it so similar? A small example
doesn't do this justice, but in games it is very common to need a lot of
variables that track state of things that happen across frames, which
are often used in just a single method, and end up cluttering the class
they are in. By using <code>member</code>, you put the declaration
closer to where it is used, which makes it easier to view all
occurrences in larger classes. It also makes it easy to see that the
variable is used only in a single method. This reduces "cognitive load"
in understanding the code, compared to seeing a long list of member
variables at the top of a class and not knowing what their relationship
is. Seeing that the variable is local to, say, <code>render()</code>
also gives additional information what the variable may be used for.</p>
<p>Currently, <code>member</code> must occur in a function declaration
that is declared inside a class (not a struct), restrictions that may be
lifted in the future.</p>
<p>You can do the same for functions outside of classes with the keyword
<code>static</code>:</p>
<pre><code>let a = 1
def bar():
    static b = 2
    b += a
    return b</code></pre>
<p>Which again is pretty much the same as writing:</p>
<pre><code>let a = 1
var b = 2
def bar():
    b += a
    return b</code></pre>
<p>With again the main difference being that in the former,
<code>b</code>'s scope is restricted to <code>bar</code>. This is not as
useful as <code>member</code> because there is only ever one instance
possible, but still nice to use when you can to simplify the complexity
of global scope elements.</p>
<p>But these two features are just the start of the real fun: the
<code>member_frame</code> and <code>static_frame</code> keywords. These
behave like their counterparts above, with one subtle difference: they
will be reset to their initializer whenever a frame does NOT use the
variable. Or rather, their state is persisted as long as frames keep
using the state. It's like "immediate mode", but for state. For example
using <code>static_frame</code> (<code>member_frame</code> works the
same other than where the variable is stored):</p>
<pre><code>def foo():
    static_frame b = 0
    print b++

gl.window(&quot;foo&quot;, 100, 100)
while gl.frame():
    static a = 0
    a++
    if a % 4:
        foo()
    else:
        print &quot;/&quot;</code></pre>
<p>This will print an endless sequence of
<code>0 1 2 / 0 1 2 / 0 1 2 / ..</code> until you close the window. Why
is this special? Notice that <code>foo</code> didn't need to be told
when to reset its sequence, that was automatic. In a game, you often
have a lot of systems and states those systems can be in, and when
something changes (the user goes into a menu or a particular gameplay or
animation state), all these systems need to be "updated" to be aware of
the new situation. Here, much like with an immediate mode gui where you
don't need to worry about creating and deleting widgets, simple control
flow can dictate what systems are "active", and their associated state
automatically gets reset when the situation changes. It's as if the
variable <code>b</code> doesn't exist when <code>foo</code> is not being
used, and it automatically gets created/deleted for you.</p>
<p>variables declared this way use more space and an extra check (an
extra variable to check the frame count) but otherwise function just
like normal variables, so you should feel free to use them wherever they
make the code simpler/clearer.</p>
<h3 id="constructor-functions">Constructor functions</h3>
<p>As shown above, a user defined type always comes with a plain
constructor that requires exactly all initialized fields in
<code>{}</code>. That is sufficient for most cases but sometimes you may
want to do additional processing on the inputs where the mapping from
inputs to fields in not 1:1.</p>
<p>In that case you can declare a function with the keyword
<code>constructor</code> instead of <code>def</code>:</p>
<pre><code>constructor Foo(n:int):
    return Foo { map(n): 0, map(n): 1 }</code></pre>
<p>This function behaves like a normal function, except that it marks
type <code>Foo</code> as having a constructor, and hence forth doesn't
allow code outside of this function to be constructed using a plain
<code>{}</code> constructor, it must call this function instead. This is
because a constructor may encode an invariant, such as in this case that
the object is always initialized to two vectors of the same length with
elements initialized to 0 and 1 respectively. You couldn't do this with
a plain constructor, since there would be no way to take the variable
<code>n</code> into account.</p>
<p>Another common case is wanting to make a variable non-nil, but there
is no way to construct a general instance of the type that would work
for all cases. Now you can make it depend on a caller supplied
argument.</p>
<p>You call these constructors with regular function calling syntax
(e.g. <code>Foo(10)</code>) instead of with <code>{}</code>, to make it
clear that additional code may be executed beyond plain field
initialization (and that a function is called).</p>
<p>You may create overloads for constructors much like regular
functions, or even make them dynamically dispatch, as long as they all
result in the given type.</p>
<h2 id="typing">Typing</h2>
<p>Lobster is statically typed, though most of the time you don’t
notice, since most types can be inferred. You specify types:</p>
<ul>
<li><p>To define overloaded / dynamic dispatched functions (see
earlier).</p></li>
<li><p>To provide coercion (<code>int</code> -&gt; <code>float</code>,
anything -&gt; <code>string</code>)</p></li>
<li><p>As documentation.</p></li>
<li><p>To get simpler/earlier type errors.</p></li>
</ul>
<p>As we've seen, you can type function arguments and UDT fields.</p>
<p>For more detail, see the <a href="type_checker.html">type
system</a>.</p>
<h2 id="enums">Enums</h2>
<pre><code>enum example:
    foo = 1
    bar
    baz</code></pre>
<p>An <code>enum</code> defines a "strongly typed alias" for the
<code>int</code> type. What this means is that these values are fully
compatible with <code>int</code> in any use, but a regular
<code>int</code> can't be passed to a context where an enum type is
explicitly requested.</p>
<p>You can convert integers explicitly to an enum with a coercion
function, e.g. <code>example(1)</code> will create a value equivalent in
type and value to <code>foo</code>.</p>
<p>If you leave out the <code>= 1</code>, the sequence will start at
<code>0</code> instead. Values automatically increment from the last
explicitly specified value, so <code>bar</code> will be <code>2</code>
here. Instead of <code>enum</code> you can use <code>enum_flags</code>,
which changes the default first value to <code>1</code> and uses
<code>* 2</code> to get to next value instead of <code>+ 1</code>.</p>
<p>Functions like <code>string</code>, <code>print</code> will get you
the name of an enum value, and likewise <code>parse_data</code> can turn
these names into enum values (when part of a data structure).</p>
<p>When you use an enum in a <code>switch</code>, it is an error to not
test all values of an enum (if there is no default case).</p>
<h3 id="booleans">Booleans</h3>
<p>A bool is not a built-in type, rather it is defined as an
<code>enum</code> in <code>stdtype.lobster</code>:</p>
<pre><code>enum bool:
    false
    true</code></pre>
<p>Because they are enums, they have the same typing rules: a
<code>bool</code> can be used anywhere an <code>int</code> is expected,
but not the other way around. Similarly, you can use e.g.
<code>bool(1)</code> to convert ints.</p>
<h2 id="programs-structure">Programs Structure</h2>
<p>A lobster program is like the body of a function: a list of
expressions on separate lines, defined by a single file, the main file
of your program. At this top level of a file, you can additionally use
the <code>import</code> keyword to bring additional code into your
program:</p>
<pre><code>import std</code></pre>
<p>The contents of that file will be merged into your main file at the
location of the <code>import</code> for the purpose of compilation. If
you you import the same file twice, the second occurrence will be
ignored.</p>
<p>An identifier like <code>std</code> is the same as specifying
<code>"std.lobster"</code>, similarly <code>a.b</code> is short for
<code>"a/b.lobster"</code>.</p>
<p>Modules will typically be loaded relative to 2 locations: the current
main <code>.lobster</code> file being compiled, and wherever the lobster
compiler is installed. In both those locations, files may be optionally
be found under an <code>modules</code> sub-directory. You can use
<code>import from "path/to/"</code> to provide additional such starting
directories (relative to the current main <code>.lobster</code> file
being compiled) that any following import statements (recursively) can
use.</p>
<p>You may use the keyword <code>private</code> at the top level in a
file to prefix structs, variables, functions, enums, fields and methods
that you don't want to be visible outside that file.</p>
<h2 id="memory-management">Memory Management</h2>
<p>Lobster uses (compile time) reference counting as its form of
management for many reasons. Besides simplicity and space efficiency,
reference counting makes a language more predictable in how much time is
spent for a given amount of code, since memory management cost is spread
equally through all code, instead of causing possibly long pauses like
with garbage collection. Lobster has a custom allocator that is very
fast.</p>
<p>Most reference counting happens at compile time using a "lifetime
analysis" algorithm, details <a
href="memory_management.html">here</a>.</p>
<p>Reference counting has one problem, which is that it can't deallocate
cycles. For example, this code:</p>
<pre><code>class rec:
    r:rec?

var x = nil
x = rec { nil }
x.r = x
x = nil</code></pre>
<p>will cause a memory leak, since initially the object that
<code>x</code> points at has a reference count of 1, then that count
increases to 2 because it now points to itself, and then when the count
is reduced to 1 because of <code>x</code>'s reference going away, we now
have an object with no outside references that still thinks its being
referenced, thus not deallocated. That is a leak. Now this is a simple
example, but in the general case with complex data structures, it is not
generally possible for a programming language to ensure this never
happens.</p>
<p>Leaks like these are not common, as they only occur with graph-like
structures or "parent reference" common in more complicated data
structures. An example in a game might be if two game units refer to
each other as their "enemy", and then both die at the same time with the
programmer forgetting to reset the enemy field before they die.</p>
<p>Lobster deals with this by detecting that such objects are left over
at the end of the program, and alerting the programmer that there are
leaks. It then outputs a "leak report" with all leaks in somewhat
readable form (with types and values), making it easier for the
programmer to figure out what caused the leak. The programmer can then
easily fix the leak by setting the reference causing the cycle to
<code>nil</code>, like clearing the enemy field when a unit dies, or by
writing <code>x.r = nil</code> in the above simplified example.</p>
<p>More details on Lobster's <a href="memory_management.html">memory
management</a>.</p>
<h2 id="control-structures">Control Structures</h2>
<p>As noted, all of these follow closely the function call syntax
introduced above as much as possible, but are otherwise treated
specially by the language.</p>
<p><code>if</code> may be followed by multiple <code>elif</code> blocks
and a single <code>else</code> block:</p>
<pre><code>if a &lt; 0:
    print &quot;negativity not allowed!&quot;
elif a &lt; 10:
    print &quot;single digit!&quot;
elif a &lt; 100:
    print &quot;double digit!&quot;
else:
    print &quot;way too big!&quot;</code></pre>
<p><code>elif</code> is simply short for writing <code>else: if</code>.
You can also write these on a single line, which is only recommended
when very short, e.g. <code>if a &lt; 0: 0 else: a</code></p>
<p><code>for</code> is the only built-in construct taking 0 to 2
arguments to the block: the element being iterated over, and iteration
index.</p>
<p>We can iterate over vectors (each element), strings (each byte), or
integers (values 0..N-1):</p>
<pre><code>for(&quot;hello&quot;) a, i:
    print &quot;{i}: {a}&quot;</code></pre>
<p>Here <code>a</code> will contain the 5 characters and <code>i</code>
will be just <code>0</code> to <code>4</code>.</p>
<p>The module <code>std</code> contains further useful loop constructs
on top of <code>for</code>, like <code>map</code>, <code>filter</code>,
and <code>exists</code> etc.</p>
<p><code>while</code> is an odd function, since it is an exception to
the rule of Lobster syntax:</p>
<pre><code>while a &lt; 10: a++</code></pre>
<p>That looks perfectly normal, but one thing should stand out: while
takes not one, but 2 function values. Normally, in Lobster, this would
make more sense:</p>
<pre><code>while():
    a &lt; 10
do:
    a++</code></pre>
<p>but since people are so used to the way while loops work from other
languages, the first argument has a special type that automatically
converts an expression into a function value. When you think about it,
even in languages like C the condition of a while is the only part of
the language that can be executed more than once yet does not use /
cannot use the block <code>{}</code> syntax. This exception is carried
over in Lobster. This is not great for readability so isn't generally
used elsewhere.</p>
<p><code>while</code> returns void. A similar function int module
<code>std</code> called <code>collectwhile</code> returns a vector of
all body return values.</p>
<p>Both <code>for</code> and <code>while</code> can have a break
statement inside of them, that exits the enclosing loop. Alternatively,
use <code>return</code> or <code>return from</code> (see above) for more
complex cases.</p>
<p>Many other functions that look like regular functions are actually
also control structures, like many of the graphics function that change
the current rendering state. An example is <code>gl.translate</code>,
that optionally takes a body, and will run the body and restore the
previous transform afterwards.</p>
<p><code>switch</code> has special syntax, since it does a lot of things
different:</p>
<pre><code>var st = switch i:
        case 1: &quot;no&quot;
        case 2, 3:
            var x = i
            &quot;yes{x}&quot;
        case 4..6, 8: &quot;maybe&quot;
        default: &quot;what?&quot;</code></pre>
<p>The value you switch on may be int, float, string or class instance.
Cases may test for multiple values, even ranges (which are inclusive).
When testing for class instances, the cases are types which must
exhaustively cover all non-abstract sub-classes of the class type.</p>
<p><code>guard</code> is a special variant of <code>if</code> for
writing code in "early-out" style:</p>
<pre><code>guard a &gt;= 0:
    print &quot;error: a is negative!&quot;
imagine_10_lines_of_code_processing_a_here()</code></pre>
<p>Is equivalent to:</p>
<pre><code>if a &gt;= 0:
    imagine_10_lines_of_code_processing_a_here()
else:
    print &quot;error: a is negative!&quot;</code></pre>
<p>Why would you want this over a traditional if-else? The idea that
code becomes easier to read if it is written in a more linear style,
dealing with all cases where the code does not apply first, before
getting to the main body of code. This becomes more obvious if you use
nested if-thens.</p>
<p>A lot of code tends to use a <code>return</code> inside an
<code>if</code> for this early-out style of programming, but that has
the problem that it only works at the top level of a function.
<code>guard</code> works for code anywhere, and does not require the
extra <code>return</code> statement.</p>
<p>If there is no code to run in the error/exceptional case, you may
even shorten it to:</p>
<pre><code>guard a &gt;= 0
imagine_10_lines_of_code_processing_a_here()</code></pre>
<p>Is equivalent to:</p>
<pre><code>if a &gt;= 0:
    imagine_10_lines_of_code_processing_a_here()</code></pre>
<p>That reads like an <code>assert</code> except instead of aborting the
program, it skips the rest of the block.</p>
<h2 id="modules-and-name-spaces">Modules and Name Spaces</h2>
<p>A module is simply a single <code>.lobster</code> file, that can be
imported into another using the <code>import</code> keyword. You can
<code>import</code> a module from multiple files and it will only be
compiled once.</p>
<p>You can prefix any top-level declaration by <code>private</code> to
cause it not be available to users of the module.</p>
<p>Lobster has a namespacing mechanism that uses <code>.</code> for
separating namespaces:</p>
<pre><code>namespace foo

class bar:
    x = 1

def baz(): return bar {}</code></pre>
<p>Names <code>bar</code> and <code>baz</code> can be used as-is inside
this module, but must be referred to as <code>foo.bar</code> and
<code>foo.baz</code> outside of this module. Non-top level items like
<code>x</code> are not affected.</p>
<p>Most built-in functions come with a namespace, such as
<code>gl</code> etc.</p>
<p>Since namespaces look the same as object dereferencing, it is
recommended to use a name with a leading uppercase for namespaces
wherever possible.</p>
<h2 id="declaration-order">Declaration order</h2>
<p>Lobster is a language that relies heavily on type inference and
generic types, and generally not requiring you to specify types, the
order in which things get type-checked sometimes matters.</p>
<p>Lobster type-checks function calls in call order, but type
declaration in the order in which they are specified in the source code,
or imported.</p>
<p>As such, to allow the maximum amount of freedom it what can refer to
what, it is recommended to import files and declare types (structs and
classes) as much as possible in the order of dependencies (least
dependent things first), and call functions from top level (which
triggers a lot of use of these types) only after all have been
declared.</p>
<p>This is not always possible, so there are ways to declare things
ahead of definition, for example:</p>
<pre><code>class Monster</code></pre>
<p>(note the lack of <code>:</code> introducing the definition)
pre-declares this type, so it can be referred to by types defined before
<code>Monster</code> is finally defined. This allows for circular
dependencies.</p>
<p>Similarly, you may declare variables before you define them:</p>
<pre><code>class World
var world:World

// Lots of types that may want to access `world` as a global in their methods goes here.
// Then finally `World` gets defined based on the earlier types.

var world:World = World {}
world.init()</code></pre>
<p>It is an error to access <code>world</code> by code in between its
declaration and definition. Typically, all code accessing
<code>world</code> in any methods in between only gets called below, so
this works out fine.</p>
<h2 id="type-checking">Type Checking</h2>
<p>This has its own document, <a href="type_checker.html">here</a>.</p>
<h2 id="built-in-functions">Built-in Functions</h2>
<p>Please refer to the <a
href="builtin_functions_reference.html">built-in function
reference</a>.</p>
<h2 id="string-interpolation">String Interpolation</h2>
<p>This is a convenience feature that allows you to write arguments to
string conversion inline in the string, instead of endless amounts of
<code>" + "</code> separators, which tends to be less readable for
longer sequences.</p>
<pre><code>&quot;a = {a} and b = {b}&quot;  // Same as: &quot;a = &quot; + a + &quot; and b = &quot; + b
&quot;a = {f(a) + 1}&quot;       // Same as: &quot;a = &quot; + (f(a) + 1)
&quot;{a}&quot;                  // Same as: string(a)</code></pre>
<p>Because of this feature, if you actually want to put <code>{</code>
or <code>}</code> in a string constant, they must be escaped (by using 2
of them, or prefixing with a <code>\</code>), e.g.</p>
<pre><code>let a = 42
print &quot;\{ {a} \}&quot;  // Prints: &quot;{ 42 }&quot;</code></pre>
<h2 id="multi-threading">Multi-threading</h2>
<p>Lobster has built-in multi-threading functionality, that is in its
early stages.</p>
<p>It is different from multi-threading in most other languages, in that
it does not allow threads to share memory or any other VM state. It
essentially runs one Lobster VM per hardware thread / core, each running
an independent and isolated copy of your Lobster program. This prevents
entire classes of potential concurrency bugs, like race conditions.</p>
<p>Communication/synchronisation between the threads is explicit through
the use of a "tuple space" (a bag of Lobster objects used as messages)
which are copied rather than shared. While copying is potentially slower
than sharing, it allows each Lobster VM to run as-if it was
single-threaded, with no synchronisation primitives to slow it down (for
example, memory allocators in Lobster are single-threaded), no GIL
(global interpreter lock) or other multi-threading overhead, so overall
performance can easily be higher than shared memory concurrency
systems.</p>
<p>The use of tuple spaces and 1 VM per thread suits "worker" style
concurrency, for example if you have 100 parallel tasks to perform, you
throw each of those in the tuple space, and the individual VMs grab and
complete them, given automatic load balancing for however many cores are
available.</p>
<p>For now, the easiest way to get a feel for how this works is to read
<code>samples/threads.lobster</code>.</p>
</body>
</html>
