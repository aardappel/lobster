<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head>
<meta content="text/html; charset=ISO-8859-1" http-equiv="content-type"><title>C-style language Cheat Sheet for Lobster</title>

<style type="text/css">
table, tr, td {font-size: 10pt;border: 1pt solid #DDDDDD; border-Collapse: collapse; max-width:1200px; vertical-align:top}
</style></head>
<body>
<div style="text-align: center;"><big style="font-family: Consolas;"><big><big>C-style
language to Lobster Cheat Sheet</big></big></big><br style="font-family: Consolas;">
<span style="font-family: Consolas;"></span><br style="font-family: Consolas;">
</div>
<table style="width: 100%; font-family: Consolas; text-align: left; margin-left: auto; margin-right: auto;" border="1" cellpadding="2" cellspacing="2">
<tbody>
<tr>
<td>Since
every programmer usually knows at least one C-style language
(C/C++/C#/Java/JavaScript/PHP etc.), a quick way to get to know Lobster
is seeing how it differs from what you're familiar with. Where C-style
languages differ I will by default pick C# (as being the most
&nbsp;"average" of the range), though sometimes may show multiple
language alternatives (as noted in the comments). This document mostly
focusses on things that are different, i.e. you will not see how a + b
in Lobster is the same as a + b in C#.</td>
</tr>
</tbody>
</table>
<div style="text-align: center;"><big><big><span style="font-family: Consolas;"><br>
Basics</span></big></big><br style="font-family: Consolas;">
<br style="font-family: Consolas;">
</div>
<table style="font-family: Consolas; width: 100%; height: 100%; text-align: left; margin-left: auto; margin-right: auto;" border="1" cellpadding="4" cellspacing="0">
<tbody>
<tr>
<td style="font-weight: bold;"><big>Lobster
version</big></td>
<td style="font-weight: bold;"><big>C-style
version</big></td>
<td style="font-weight: bold;"><big>Comments</big></td>
</tr>
<tr><td>a = 1</td><td>a = 1;</td><td>Assign existing variable.</td></tr><tr><td>var a = 1</td><td>int a = 1;</td><td>Create new variable, type thru type inference.</td></tr><tr><td>let a = 1</td><td>const int a = 1;</td><td>Create constant variable.</td></tr>


<tr>
<td>let a, b&nbsp;= 1, 2</td>
<td>int a = 1; int b = 2;</td>
<td>Define multiple at once.</td>
</tr>
<tr>
<td>let a, b&nbsp;= f()</td>
<td>int a = f(&amp;b);</td>
<td>Define multiple from a function returning multiple values.</td>
</tr>
<tr>
<td style="white-space: nowrap;">let v&nbsp;= [ 1, 2, 3 ]</td>
<td>int[] v = new int[] { 1, 2, 3 };</td>
<td>The type of vectors is inferred. They are also resizable, so they are probably more
akin a C# List than an array.</td>
</tr>
<tr>
<td>let w&nbsp;= v + v</td>
<td style="white-space: nowrap;">vec3 w = new Vec3;<br>w.x = v.x + v.x;<br>w.y = v.y + v.y;<br>w.z = v.z + v.z;</td>
<td>Vector operation exist for most operators and functions.</td>
</tr>
<tr>
<td>nil</td>
<td>null</td>
<td>Nil is more strict in lobster, in that a reference type which can
be nil is different from those that are never nil, and you explicitly
convert between them.</td>
</tr>
<tr>
<td>a or b and c</td>
<td>(a || b) &amp;&amp; c</td>
<td>These are really the only operators that are different.</td>
</tr>
<tr>
<td>let a&nbsp;= f() or g()</td>
<td>var a = f();<br>
if (a == null) a = g();</td>
<td>The or operator works slightly differently in that
rather than returning true, it returns whatever value was true (and
true is everything that is not nil, false, 0 or 0.0)</td>
</tr>
</tbody>
</table>
<div style="text-align: center;"><br style="font-family: Consolas;">
<br style="font-family: Consolas;">
<big><big><span style="font-family: Consolas;">Control
Structures</span></big></big><br style="font-family: Consolas;">
<br style="font-family: Consolas;">
</div>
<table style="font-family: Consolas; width: 100%; height: 100%; text-align: left; margin-left: auto; margin-right: auto;" border="1" cellpadding="4" cellspacing="0">
<tbody>
<tr>
<td style="font-weight: bold;"><big>Lobster
version</big></td>
<td style="font-weight: bold;"><big>C-style
version</big></td>
<td style="font-weight: bold;"><big>Comments</big></td>
</tr>
<tr>
<td>if a: b else: c</td>
<td>if (a) b; else c</td>
<td></td>
</tr>
<tr>
<td>if a:<br>
&nbsp; &nbsp; b<br>
&nbsp; &nbsp; c<br>
else:<br>
&nbsp; &nbsp; d<br>
&nbsp; &nbsp; e</td>
<td>if (a) {<br>&nbsp; &nbsp; b;<br>&nbsp; &nbsp; c;<br>} else {<br>&nbsp; &nbsp;&nbsp;d;<br>&nbsp; &nbsp;&nbsp;e;<br>}</td>
<td></td>
</tr>
<tr>
<td>for(m) i: print i</td>
<td>for (int i = 0; i &lt; m; i++) print(i);</td>
<td></td>
</tr>
<tr>
<td>for m: print _</td>
<td>for (int i = 0; i &lt; m; i++) print(i);</td>
<td></td>
</tr>
<tr>
<td>for(m) i:<br>
&nbsp; &nbsp; print i</td>
<td>for (int i = 0; i &lt; m; i++) {<br>
&nbsp; &nbsp; print(i);<br>
}</td>
<td></td>
</tr>
<tr>
<td>while a: b</td>
<td>while (a) b;</td>
<td></td>
</tr>

<tr>
<td>for(list) a: print a</td>
<td>foreach (var a in list) print(a);</td>
<td></td>
</tr>
<tr><td>a := switch i:<br>&nbsp; &nbsp; case 1: "no"<br>&nbsp; &nbsp; case 2, 4..6: "yes"<br>&nbsp; &nbsp; default: "maybe"</td><td>switch (i) {<br>&nbsp; &nbsp; case 1:<br>&nbsp; &nbsp; &nbsp; &nbsp; a = "no";<br>&nbsp; &nbsp; &nbsp; &nbsp; break;<br>&nbsp; &nbsp; case 2:<br>&nbsp; &nbsp; case 4:<br>&nbsp; &nbsp; case 5:<br>&nbsp; &nbsp; case 6:<br>&nbsp; &nbsp; &nbsp; &nbsp; a = "yes";<br>&nbsp; &nbsp; &nbsp; &nbsp; break;<br>&nbsp; &nbsp; default:<br>&nbsp; &nbsp; &nbsp; &nbsp; a = "maybe";<br>}</td><td></td></tr><tr>
<td>r := map(list) x: x * x</td>
<td>var r = new List();<br>
foreach(var x in list) r.Add(x * x);</td>
<td><br>
</td>
</tr>
<tr>
<td>r := map(list) x: x * x</td>
<td>var r = list.ConvertAll(x =&gt; x * x);</td>
<td>C# and pretty much all programming languages except for
Java (&lt; 8) can nowadays use some form of lambdas that are similar but not
quite as powerful as the ones in Lobster (for example, you can't use
"return" to break out of a loop).</td>
</tr>
<tr>
<td>r := filter list: _ &gt; 0</td>
<td>var r = new List();<br>
foreach (var x in list) if (x
&gt; 0) r.Add(x);</td>
<td></td>
</tr>
<tr>
<td style="white-space: nowrap;">r := exists list: _ &gt; 0</td>
<td style="white-space: nowrap;">var r = false;<br>
foreach (var x in list) if (x
&gt; 0) { r = true; break; }</td>
<td></td>
</tr>

</tbody>
</table>
<div style="text-align: center;"><br style="font-family: Consolas;">
<br style="font-family: Consolas;">
<big><big><span style="font-family: Consolas;">Function
Definitions
and Scope</span></big></big><br style="font-family: Consolas;">
<br style="font-family: Consolas;">
</div>
<table style="font-family: Consolas; width: 100%; height: 100%; text-align: left; margin-left: auto; margin-right: auto;" border="1" cellpadding="4" cellspacing="0">
<tbody>
<tr>
<td style="font-weight: bold;"><big>Lobster
version</big></td>
<td style="font-weight: bold;"><big>C-style
version</big></td>
<td style="font-weight: bold;"><big>Comments</big></td>
</tr>
<tr><td>def&nbsp;name(a:int, b:int) -&gt; int:<br>&nbsp; &nbsp;&nbsp;return a + b</td><td>int name(int a, int b) { return a + b; }</td><td>In Lobster it is unusual to specify types, especially the return type.</td></tr><tr>
<td>def&nbsp;name(a, b):<br>&nbsp; &nbsp; return a + b</td>
<td>T&nbsp;name&lt;T&gt;(T a, T b) { return a + b; }</td>
<td>By default function are declared without types, and automatically inferred on use.<br></td>
</tr>
<tr>
<td>def&nbsp;name(a, b):<br>
&nbsp; &nbsp; return a + b</td>
<td>T&nbsp;name&lt;T&gt;(T a, T b) {<br>
&nbsp; &nbsp; return a + b;<br>
}</td>
<td>For multiple lines, use indentation.</td>
</tr>
<tr>
<td style="white-space: nowrap;">def&nbsp;magnitude(v::xy):<br>&nbsp; &nbsp; return sqrt(x * x + y * y)</td>
<td style="white-space: nowrap;">// inside class xy<br>
float&nbsp;magnitude() { return sqrt(x * x + y * y); }</td>
<td>The :: way to indicate a type (v is of type xy) allows you to access
object elements directly rather than having to write v.x etc. This is
similar to writing a&nbsp;method, though Lobster makes no such distinction.</td>
</tr>
<tr><td>// inside class/struct xy<br>def&nbsp;magnitude():<br>&nbsp; &nbsp; return sqrt(x * x + y * y)</td><td>// inside class xy<br>
float&nbsp;magnitude() { return sqrt(x * x + y * y); }</td><td>This is an equivalent way of writing the above when inside the scope of a class/struct (see below).</td></tr><tr>
<td>v.magnitude()</td>
<td>v.magnitude()</td>
<td>On a function call, you can move the first argument to
before the call, for <span style="font-style: italic;">any</span>
function, not just "methods".</td>
</tr>
<tr>
<td>def&nbsp;name(x:X): return 0<br>
def name(y:Y): return 1</td>
<td>/* inside class X */ int name() { return 0; }<br>
/* inside class Y */ int name() { return 1; }</td>
<td>You write multiple function implementations for multiple types,
which can then be called and resolved either statically (overloading)
or dynamically (dynamic dispatch) depending on the situation. These
functions can work on user defined
types or builtin ones. They can be written by whoever wrote the type
(even in-line in the class definition), or completely separately. </td>
</tr>

<tr>
<td>let f&nbsp;= def(a, b):&nbsp;a + b</td>
<td>var f = (int a, int b) =&gt; a + b</td>
<td>Function value in C#</td>
</tr>
<tr>
<td>let f&nbsp;= def(a, b): a + b</td>
<td>auto f = [](int a, int a) { return a + b; }</td>
<td>Function value in C++</td>
</tr>
<tr>
<td>def&nbsp;fold(xs, init, fun): <br>&nbsp;&nbsp;&nbsp; for(xs): init = fun(init, _)<br>&nbsp;&nbsp;&nbsp; return init</td>
<td>T fold&lt;T&gt;(List&lt;T&gt; xs, T init, Func&lt;T, T, T&gt; fun) {<br>&nbsp; &nbsp; foreach (var x in xs) init = fun(init, x);<br>&nbsp; &nbsp; return init;<br>}</td>
<td>How to write a <span style="font-style: italic;">Higher Order Function</span>:
a function that takes a function argument. In this case "fold": take a
list, and apply the function to each element and the previous result,
effectively "folding" the list into a single value.</td>
</tr>
<tr>
<td>r := fold(list, 0) a, b: a + b</td>
<td>var r = fold(list, 0, (a, b) =&gt; a + b);</td>
<td>How to call that function with a function value. This sums all values in a list.</td>
</tr>
<tr>
<td>r := fold(list, 0): _a + _b</td>
<td>var r = fold(list, 0, (a, b) =&gt; a + b);</td>
<td>Anonymous arguments in lexical order, see language reference.</td>
</tr>
<tr>
<td>r := fold(list, 0) a, b:<br>&nbsp; &nbsp; print a<br>&nbsp; &nbsp;&nbsp;a +&nbsp;b</td>
<td>var r = fold(list, 0, (a, b) =&gt; {<br>&nbsp; &nbsp; print(a);<br>&nbsp; &nbsp; return a + b;<br>});</td>
<td>Note how in most languages lambda syntax becomes messy when you
want to use them with a larger body, and looking very different from
builtin control structures.</td>
</tr>
<tr>
<td>r := fold(list, 0) a, b:<br>&nbsp; &nbsp; if a &lt; 0: return a<br>&nbsp; &nbsp;&nbsp;a +&nbsp;b</td>
<td>/* not possible */</td>
<td>Another way in which lambdas in most languages differ from Lobster:
you cannot return/break
from the loop, making them often useless as control structures. In
Lobster, they function just like real constrol structures would. By
default, return returns from the lexically enclosing named function.</td>
</tr>
<tr>
<td>def&nbsp;f():<br>&nbsp; &nbsp; g()<br>&nbsp; &nbsp; return 0<br>def&nbsp;g():<br>&nbsp; &nbsp; if something: return 1 from f<br>&nbsp; &nbsp; return 0</td>
<td>int f() {<br>&nbsp; &nbsp; try { g(); return 0; }<br>&nbsp; &nbsp; catch (int x) { return x; }<br>}<br>int g() {<br>&nbsp; &nbsp; if (something) throw 1;<br>&nbsp; &nbsp; return 0;<br>}</td>
<td>Return even allows you to specify which function to return from,
which in other languages you can do with exception handling. In fact,
exception handling in Lobster is not a language feature, it is simply
some utility functions (try/catch/...) implemented on top of
return/from (implemented in exception.lobster).</td>
</tr>










<tr>
<td>def&nbsp;mret(): return 1, 2</td>
<td style="white-space: nowrap;">int mret(out int o)
{ o = 2; return 1; }</td>
<td></td>
</tr>
<tr>
<td>let a, b&nbsp;= mret()</td>
<td>var b; var a = mret(&amp;b);</td>
<td></td>
</tr>




</tbody>
</table>
<div style="text-align: center;"><br style="font-family: Consolas;">
<br style="font-family: Consolas;">
<big><big><span style="font-family: Consolas;">User
Defined Types</span></big></big><br style="font-family: Consolas;">
<br style="font-family: Consolas;">
</div>
<table style="font-family: Consolas; width: 100%; height: 100%; text-align: left; margin-left: auto; margin-right: auto;" border="1" cellpadding="4" cellspacing="0">
<tbody>
<tr>
<td style="font-weight: bold;"><big>Lobster
version</big></td>
<td style="font-weight: bold;"><big>C-style
version</big></td>
<td style="font-weight: bold;"><big>Comments</big></td>
</tr>
<tr>
<td>struct xy:<br>&nbsp; &nbsp;&nbsp;x:float<br>&nbsp; &nbsp;&nbsp;y:float</td>
<td>public struct xy { float x; float y; }</td>
<td><br></td>
</tr>
<tr>
<td>struct xy&lt;T&gt;<br>&nbsp; &nbsp;&nbsp;x:T<br>&nbsp; &nbsp;&nbsp;y:T</td>
<td>public struct xy&lt;T&gt; { T x; T y; }</td>
<td>Generics: unlike functions, these are explicitly specified in Lobster.</td>
</tr>

<tr>
<td>struct xyz : xy:<br>&nbsp; &nbsp;&nbsp;z:float</td>
<td>public struct xyz : xy { float z; }</td>
<td>Inheritance.</td>
</tr>
<tr>
<td>let v&nbsp;= xyz { 1, 0, 0 }</td>
<td>var v = new xyz(1, 0, 0)</td>
<td>You'd actually have to define the constructor in C# to
be able to do this.</td>
</tr><tr><td>struct xy:<br>&nbsp; &nbsp; x:float<br>&nbsp; &nbsp; y:float<br>&nbsp; &nbsp; def&nbsp;magnitude():<br>&nbsp; &nbsp; &nbsp; &nbsp; return sqrt(x * x + y * y)</td><td>public class xy {<br>&nbsp; &nbsp; float x;<br>&nbsp; &nbsp; float y;<br>
&nbsp; &nbsp; float&nbsp;magnitude() {<br>&nbsp; &nbsp; &nbsp; &nbsp; return x * x + y * y;<br>&nbsp; &nbsp; }<br>}</td><td>Intendation based syntax, with inline function definition (automatic this argument).</td></tr><tr><td>enum color:<br>&nbsp; &nbsp; red = 1<br>&nbsp; &nbsp; green<br>&nbsp; &nbsp; blue<br>&nbsp; &nbsp; yellow = 10</td><td>enum color {<br>&nbsp; &nbsp; red = 1,<br>&nbsp; &nbsp; green,<br>&nbsp; &nbsp; blue,<br>&nbsp; &nbsp; yellow = 10<br>}</td><td></td></tr>







</tbody>
</table>
<div style="text-align: center;"><br><br></div>
</body></html>
