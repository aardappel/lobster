<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<title>lobster builtin function reference</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<style type="text/css">table.a, tr.a, td.a {font-size: 10pt;border: 1pt solid #DDDDDD; border-Collapse: collapse; max-width:1200px}</style>
</head>
<body><center><table border=0><tr><td>
<p>lobster builtin functions:(file auto generated by compiler, do not modify)</p>

<h3>builtin</h3>
<table class="a" border=1 cellspacing=0 cellpadding=4>
<tr class="a" valign=top><td class="a"><tt><b>print</b>(x<font color="#666666">:string</font>)</tt></td><td class="a">output any value to the console (with linefeed).</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>string</b>(x<font color="#666666">:string</font>) -> <font color="#666666">string</font></tt></td><td class="a">convert any value to string</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>set_print_depth</b>(depth<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">for printing / string conversion: sets max vectors/objects recursion depth (default 10), returns old value</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>set_print_length</b>(len<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">for printing / string conversion: sets max string length (default 100000), returns old value</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>set_print_quoted</b>(quoted<font color="#666666">:bool</font>) -> <font color="#666666">int</font></tt></td><td class="a">for printing / string conversion: if the top level value is a string, whether to convert it with escape codes and quotes (default false), returns old value</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>set_print_decimals</b>(decimals<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">for printing / string conversion: number of decimals for any floating point output (default -1, meaning all), returns old value</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>set_print_indent</b>(spaces<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">for printing / string conversion: number of spaces to indent with. default is 0: no indent / no multi-line, returns old value</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>get_line</b>(prefix<font color="#666666">:string</font>) -> <font color="#666666">string</font></tt></td><td class="a">reads a string from the console if possible (followed by enter). Prefix will be printed before the input</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>append</b>(xs<font color="#666666">:[any]</font>, ys<font color="#666666">:[any]</font>) -> <font color="#666666">[any]</font></tt></td><td class="a">creates a new vector by appending all elements of 2 input vectors</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>append_into</b>(dest<font color="#666666">:[any]</font>, src<font color="#666666">:[any]</font>) -> <font color="#666666">[any]</font></tt></td><td class="a">appends all elements of the second vector into the first</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>vector_capacity</b>(xs<font color="#666666">:[any]</font>, len<font color="#666666">:int</font>) -> <font color="#666666">[any]</font></tt></td><td class="a">ensures the vector capacity (number of elements it can contain before re-allocating) is at least "len". Does not actually add (or remove) elements. This function is just for efficiency in the case the amount of "push" operations is known. returns original vector.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>length</b>(x<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">length of int (identity function, useful in combination with string/vector version)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>length</b>(s<font color="#666666">:string</font>) -> <font color="#666666">int</font></tt></td><td class="a">length of string</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>length</b>(xs<font color="#666666">:[any]</font>) -> <font color="#666666">int</font></tt></td><td class="a">length of vector</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>equal</b>(a<font color="#666666"></font>, b<font color="#666666"></font>) -> <font color="#666666">int</font></tt></td><td class="a">structural equality between any two values (recurses into vectors/objects, unlike == which is only true for vectors/objects if they are the same object)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>push</b>(xs<font color="#666666">:[any]</font>, x<font color="#666666"></font>) -> <font color="#666666">[any]</font></tt></td><td class="a">appends one element to a vector, returns existing vector</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>pop</b>(xs<font color="#666666">:[any]</font>) -> <font color="#666666">any</font></tt></td><td class="a">removes last element from vector and returns it</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>top</b>(xs<font color="#666666">:[any]</font>) -> <font color="#666666">any</font></tt></td><td class="a">returns last element from vector</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>insert</b>(xs<font color="#666666">:[any]</font>, i<font color="#666666">:int</font>, x<font color="#666666"></font>) -> <font color="#666666">[any]</font></tt></td><td class="a">inserts a value into a vector at index i, existing elements shift upward, returns original vector</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>remove</b>(xs<font color="#666666">:[any]</font>, i<font color="#666666">:int</font>) -> <font color="#666666">any</font></tt></td><td class="a">remove element at index i, following elements shift down. returns the element removed.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>remove_range</b>(xs<font color="#666666">:[any]</font>, i<font color="#666666">:int</font>, n<font color="#666666">:int</font>)</tt></td><td class="a">remove n elements at index i, following elements shift down.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>remove_obj</b>(xs<font color="#666666">:[any]</font>, obj<font color="#666666"></font>) -> <font color="#666666">any</font></tt></td><td class="a">remove all elements equal to obj (==), returns obj.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>binary_search</b>(xs<font color="#666666">:[int]</font>, key<font color="#666666">:int</font>) -> <font color="#666666">int</font>, <font color="#666666">int</font></tt></td><td class="a">does a binary search for key in a sorted vector, returns as first return value how many matches were found, and as second the index in the array where the matches start (so you can read them, overwrite them, or remove them), or if none found, where the key could be inserted such that the vector stays sorted. This overload is for int vectors and keys.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>binary_search</b>(xs<font color="#666666">:[float]</font>, key<font color="#666666">:float</font>) -> <font color="#666666">int</font>, <font color="#666666">int</font></tt></td><td class="a">float version.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>binary_search</b>(xs<font color="#666666">:[string]</font>, key<font color="#666666">:string</font>) -> <font color="#666666">int</font>, <font color="#666666">int</font></tt></td><td class="a">string version.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>binary_search_object</b>(xs<font color="#666666">:[any]</font>, key<font color="#666666"></font>) -> <font color="#666666">int</font>, <font color="#666666">int</font></tt></td><td class="a">object version. compares by reference rather than contents.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>copy</b>(x<font color="#666666"></font>) -> <font color="#666666">any</font></tt></td><td class="a">makes a shallow copy of any object/vector/string.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>deepcopy</b>(x<font color="#666666"></font>, depth<font color="#666666">:int</font>) -> <font color="#666666">any</font></tt></td><td class="a">makes a deep copy of any object/vector/string. DAGs become trees, and cycles will clone until it reach the given depth. depth == 1 would do the same as copy.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>slice</b>(xs<font color="#666666">:[any]</font>, start<font color="#666666">:int</font>, size<font color="#666666">:int</font>) -> <font color="#666666">[any]</font></tt></td><td class="a">returns a sub-vector of size elements from index start. size can be negative to indicate the rest of the vector.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>any</b>(xs<font color="#666666">:[any]</font>) -> <font color="#666666">int</font></tt></td><td class="a">returns whether any elements of the vector are true values</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>any</b>(xs<font color="#666666">:vec_i</font>) -> <font color="#666666">int</font></tt></td><td class="a">returns whether any elements of the numeric struct are true values</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>all</b>(xs<font color="#666666">:[any]</font>) -> <font color="#666666">int</font></tt></td><td class="a">returns whether all elements of the vector are true values</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>all</b>(xs<font color="#666666">:vec_i</font>) -> <font color="#666666">int</font></tt></td><td class="a">returns whether all elements of the numeric struct are true values</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>substring</b>(s<font color="#666666">:string</font>, start<font color="#666666">:int</font>, size<font color="#666666">:int</font>) -> <font color="#666666">string</font></tt></td><td class="a">returns a substring of size characters from index start. size can be negative to indicate the rest of the string.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>find_string</b>(s<font color="#666666">:string</font>, substr<font color="#666666">:string</font>, offset<font color="#666666">:int</font> = 0) -> <font color="#666666">int</font></tt></td><td class="a">finds the index at which substr first appears, or -1 if none. optionally start at a position other than 0</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>find_string_reverse</b>(s<font color="#666666">:string</font>, substr<font color="#666666">:string</font>, offset<font color="#666666">:int</font> = 0) -> <font color="#666666">int</font></tt></td><td class="a">finds the index at which substr first appears when searching from the end, or -1 if none. optionally start at a position other than the end of the string</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>replace_string</b>(s<font color="#666666">:string</font>, a<font color="#666666">:string</font>, b<font color="#666666">:string</font>, count<font color="#666666">:int</font> = 0) -> <font color="#666666">string</font></tt></td><td class="a">returns a copy of s where all occurrences of a have been replaced with b. if a is empty, no replacements are made. if count is specified, makes at most that many replacements</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>string_to_int</b>(s<font color="#666666">:string</font>, base<font color="#666666">:int</font> = 0) -> <font color="#666666">int</font>, <font color="#666666">int</font></tt></td><td class="a">converts a string to an int given the base (2..36, e.g. 16 for hex, default is 10).returns 0 if no numeric data could be parsed; second return value is true if allcharacters of the string were parsed.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>string_to_float</b>(s<font color="#666666">:string</font>) -> <font color="#666666">float</font>, <font color="#666666">int</font></tt></td><td class="a">converts a string to a float. returns 0.0 if no numeric data could be parsed;second return value is true if all characters of the string were parsed.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>tokenize</b>(s<font color="#666666">:string</font>, delimiters<font color="#666666">:string</font>, whitespace<font color="#666666">:string</font>, dividing<font color="#666666">:int</font> = 0) -> <font color="#666666">[string]</font></tt></td><td class="a">splits a string into a vector of strings, by splitting into segments upon each dividing or terminating delimiter. Segments are stripped of leading and trailing whitespace. Example: "; A ; B C;; " becomes [ "", "A", "B C", "" ] with ";" as delimiter and " " as whitespace. If dividing was true, there would be a 5th empty string element.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>unicode_to_string</b>(us<font color="#666666">:[int]</font>) -> <font color="#666666">string</font></tt></td><td class="a">converts a vector of ints representing unicode values to a UTF-8 string.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>string_to_unicode</b>(s<font color="#666666">:string</font>) -> <font color="#666666">[int]</font>, <font color="#666666">int</font></tt></td><td class="a">converts a UTF-8 string into a vector of unicode values. second return value is false if there was a decoding error, and the vector will only contain the characters up to the error</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>number_to_string</b>(number<font color="#666666">:int</font>, base<font color="#666666">:int</font>, minchars<font color="#666666">:int</font>) -> <font color="#666666">string</font></tt></td><td class="a">converts the (unsigned version) of the input integer number to a string given the base (2..36, e.g. 16 for hex) and outputting a minimum of characters (padding with 0).</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>lowercase</b>(s<font color="#666666">:string</font>) -> <font color="#666666">string</font></tt></td><td class="a">converts a UTF-8 string from any case to lower case, affecting only A-Z</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>uppercase</b>(s<font color="#666666">:string</font>) -> <font color="#666666">string</font></tt></td><td class="a">converts a UTF-8 string from any case to upper case, affecting only a-z</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>escape_string</b>(s<font color="#666666">:string</font>, set<font color="#666666">:string</font>, prefix<font color="#666666">:string</font>, postfix<font color="#666666">:string</font>) -> <font color="#666666">string</font></tt></td><td class="a">prefixes &amp; postfixes any occurrences or characters in set in string s</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>concat_string</b>(v<font color="#666666">:[string]</font>, sep<font color="#666666">:string</font>) -> <font color="#666666">string</font></tt></td><td class="a">concatenates all elements of the string vector, separated with sep.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>repeat_string</b>(s<font color="#666666">:string</font>, n<font color="#666666">:int</font>) -> <font color="#666666">string</font></tt></td><td class="a">returns a string consisting of n copies of the input string.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>pow</b>(a<font color="#666666">:int</font>, b<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">a raised to the power of b, for integers, using exponentiation by squaring</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>pow</b>(a<font color="#666666">:float</font>, b<font color="#666666">:float</font>) -> <font color="#666666">float</font></tt></td><td class="a">a raised to the power of b</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>pow</b>(a<font color="#666666">:vec_f</font>, b<font color="#666666">:float</font>) -> <font color="#666666">vec_f</font></tt></td><td class="a">vector elements raised to the power of b</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>log</b>(a<font color="#666666">:float</font>) -> <font color="#666666">float</font></tt></td><td class="a">natural logaritm of a</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>log2</b>(a<font color="#666666">:float</font>) -> <font color="#666666">float</font></tt></td><td class="a">base 2 logaritm of a</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>sqrt</b>(f<font color="#666666">:float</font>) -> <font color="#666666">float</font></tt></td><td class="a">square root</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>ceiling</b>(f<font color="#666666">:float</font>) -> <font color="#666666">int</font></tt></td><td class="a">the nearest int &gt;= f</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>ceiling</b>(v<font color="#666666">:vec_f</font>) -> <font color="#666666">vec_i</font></tt></td><td class="a">the nearest ints &gt;= each component of v</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>floor</b>(f<font color="#666666">:float</font>) -> <font color="#666666">int</font></tt></td><td class="a">the nearest int &lt;= f</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>floor</b>(v<font color="#666666">:vec_f</font>) -> <font color="#666666">vec_i</font></tt></td><td class="a">the nearest ints &lt;= each component of v</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>int</b>(f<font color="#666666">:float</font>) -> <font color="#666666">int</font></tt></td><td class="a">converts a float to an int by dropping the fraction</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>int</b>(v<font color="#666666">:vec_f</font>) -> <font color="#666666">vec_i</font></tt></td><td class="a">converts a vector of floats to ints by dropping the fraction</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>round</b>(f<font color="#666666">:float</font>) -> <font color="#666666">int</font></tt></td><td class="a">converts a float to the closest int</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>round</b>(v<font color="#666666">:vec_f</font>) -> <font color="#666666">vec_i</font></tt></td><td class="a">converts a vector of floats to the closest ints</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>fraction</b>(f<font color="#666666">:float</font>) -> <font color="#666666">float</font></tt></td><td class="a">returns the fractional part of a float: short for f - floor(f)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>fraction</b>(v<font color="#666666">:vec_f</font>) -> <font color="#666666">vec_f</font></tt></td><td class="a">returns the fractional part of a vector of floats</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>float</b>(i<font color="#666666">:int</font>) -> <font color="#666666">float</font></tt></td><td class="a">converts an int to float</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>float</b>(v<font color="#666666">:vec_i</font>) -> <font color="#666666">vec_f</font></tt></td><td class="a">converts a vector of ints to floats</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>sin</b>(angle<font color="#666666">:float</font>) -> <font color="#666666">float</font></tt></td><td class="a">the y coordinate of the normalized vector indicated by angle (in degrees)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>cos</b>(angle<font color="#666666">:float</font>) -> <font color="#666666">float</font></tt></td><td class="a">the x coordinate of the normalized vector indicated by angle (in degrees)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>tan</b>(angle<font color="#666666">:float</font>) -> <font color="#666666">float</font></tt></td><td class="a">the tangent of an angle (in degrees)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>sincos</b>(angle<font color="#666666">:float</font>) -> <font color="#666666">float2</font></tt></td><td class="a">the normalized vector indicated by angle (in degrees), same as xy { cos(angle), sin(angle) }</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>asin</b>(y<font color="#666666">:float</font>) -> <font color="#666666">float</font></tt></td><td class="a">the angle (in degrees) indicated by the y coordinate projected to the unit circle</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>acos</b>(x<font color="#666666">:float</font>) -> <font color="#666666">float</font></tt></td><td class="a">the angle (in degrees) indicated by the x coordinate projected to the unit circle</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>atan</b>(x<font color="#666666">:float</font>) -> <font color="#666666">float</font></tt></td><td class="a">the angle (in degrees) indicated by the y coordinate of the tangent projected to the unit circle</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>radians</b>(angle<font color="#666666">:float</font>) -> <font color="#666666">float</font></tt></td><td class="a">converts an angle in degrees to radians</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>degrees</b>(angle<font color="#666666">:float</font>) -> <font color="#666666">float</font></tt></td><td class="a">converts an angle in radians to degrees</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>atan2</b>(vec<font color="#666666">:float2</font>) -> <font color="#666666">float</font></tt></td><td class="a">the angle (in degrees) corresponding to a normalized 2D vector</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>radians</b>(angle<font color="#666666">:float</font>) -> <font color="#666666">float</font></tt></td><td class="a">converts an angle in degrees to radians</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>degrees</b>(angle<font color="#666666">:float</font>) -> <font color="#666666">float</font></tt></td><td class="a">converts an angle in radians to degrees</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>normalize</b>(vec<font color="#666666">:vec_f</font>) -> <font color="#666666">vec_f</font></tt></td><td class="a">returns a vector of unit length</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>dot</b>(a<font color="#666666">:vec_f</font>, b<font color="#666666">:vec_f</font>) -> <font color="#666666">float</font></tt></td><td class="a">the length of vector a when projected onto b (or vice versa)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>magnitude</b>(v<font color="#666666">:vec_f</font>) -> <font color="#666666">float</font></tt></td><td class="a">the geometric length of a vector</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>magnitude_squared</b>(v<font color="#666666">:vec_f</font>) -> <font color="#666666">float</font></tt></td><td class="a">the geometric length of a vector squared</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>magnitude_squared</b>(v<font color="#666666">:vec_i</font>) -> <font color="#666666">int</font></tt></td><td class="a">the geometric length of a vector squared</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>manhattan</b>(v<font color="#666666">:vec_i</font>) -> <font color="#666666">int</font></tt></td><td class="a">the manhattan distance of a vector</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>cross</b>(a<font color="#666666">:float3</font>, b<font color="#666666">:float3</font>) -> <font color="#666666">float3</font></tt></td><td class="a">a perpendicular vector to the 2D plane defined by a and b (swap a and b for its inverse)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>volume</b>(v<font color="#666666">:vec_f</font>) -> <font color="#666666">float</font></tt></td><td class="a">the volume of the area spanned by the vector</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>volume</b>(v<font color="#666666">:vec_i</font>) -> <font color="#666666">int</font></tt></td><td class="a">the volume of the area spanned by the vector</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>rnd</b>(max<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">a random value [0..max).</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>rnd</b>(max<font color="#666666">:vec_i</font>) -> <font color="#666666">vec_i</font></tt></td><td class="a">a random vector within the range of an input vector.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>rnd_float</b>() -> <font color="#666666">float</font></tt></td><td class="a">a random float [0..1)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>rnd_gaussian</b>() -> <font color="#666666">float</font></tt></td><td class="a">a random float in a gaussian distribution with mean 0 and stddev 1</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>rnd_seed</b>(seed<font color="#666666">:int</font>)</tt></td><td class="a">explicitly set a random seed for reproducable randomness</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>rndm</b>(max<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">deprecated: old mersenne twister version of the above for backwards compat.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>rndm_seed</b>(seed<font color="#666666">:int</font>)</tt></td><td class="a">deprecated: old mersenne twister version of the above for backwards compat.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>div</b>(a<font color="#666666">:int</font>, b<font color="#666666">:int</font>) -> <font color="#666666">float</font></tt></td><td class="a">forces two ints to be divided as floats</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>clamp</b>(x<font color="#666666">:int</font>, min<font color="#666666">:int</font>, max<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">forces an integer to be in the range between min and max (inclusive)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>clamp</b>(x<font color="#666666">:float</font>, min<font color="#666666">:float</font>, max<font color="#666666">:float</font>) -> <font color="#666666">float</font></tt></td><td class="a">forces a float to be in the range between min and max (inclusive)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>clamp</b>(x<font color="#666666">:vec_i</font>, min<font color="#666666">:vec_i</font>, max<font color="#666666">:vec_i</font>) -> <font color="#666666">vec_i</font></tt></td><td class="a">forces an integer vector to be in the range between min and max (inclusive)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>clamp</b>(x<font color="#666666">:vec_f</font>, min<font color="#666666">:vec_f</font>, max<font color="#666666">:vec_f</font>) -> <font color="#666666">vec_f</font></tt></td><td class="a">forces a float vector to be in the range between min and max (inclusive)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>in_range</b>(x<font color="#666666">:int</font>, range<font color="#666666">:int</font>, bias<font color="#666666">:int</font> = 0) -> <font color="#666666">int</font></tt></td><td class="a">checks if an integer is &gt;= bias and &lt; bias + range. Bias defaults to 0.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>in_range</b>(x<font color="#666666">:float</font>, range<font color="#666666">:float</font>, bias<font color="#666666">:float</font> = 0.000000) -> <font color="#666666">int</font></tt></td><td class="a">checks if a float is &gt;= bias and &lt; bias + range. Bias defaults to 0.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>in_range</b>(x<font color="#666666">:int2</font>, range<font color="#666666">:int2</font>, bias<font color="#666666">:int2</font> = nil) -> <font color="#666666">int</font></tt></td><td class="a">checks if a 2d integer vector is &gt;= bias and &lt; bias + range. Bias defaults to 0.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>in_range</b>(x<font color="#666666">:int3</font>, range<font color="#666666">:int3</font>, bias<font color="#666666">:int3</font> = nil) -> <font color="#666666">int</font></tt></td><td class="a">checks if a 3d integer vector is &gt;= bias and &lt; bias + range. Bias defaults to 0.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>in_range</b>(x<font color="#666666">:float2</font>, range<font color="#666666">:float2</font>, bias<font color="#666666">:float2</font> = nil) -> <font color="#666666">int</font></tt></td><td class="a">checks if a 2d float vector is &gt;= bias and &lt; bias + range. Bias defaults to 0.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>in_range</b>(x<font color="#666666">:float3</font>, range<font color="#666666">:float3</font>, bias<font color="#666666">:float3</font> = nil) -> <font color="#666666">int</font></tt></td><td class="a">checks if a 2d float vector is &gt;= bias and &lt; bias + range. Bias defaults to 0.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>abs</b>(x<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">absolute value of an integer</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>abs</b>(x<font color="#666666">:float</font>) -> <font color="#666666">float</font></tt></td><td class="a">absolute value of a float</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>abs</b>(x<font color="#666666">:vec_i</font>) -> <font color="#666666">vec_i</font></tt></td><td class="a">absolute value of an int vector</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>abs</b>(x<font color="#666666">:vec_f</font>) -> <font color="#666666">vec_f</font></tt></td><td class="a">absolute value of a float vector</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>sign</b>(x<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">sign (-1, 0, 1) of an integer</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>sign</b>(x<font color="#666666">:float</font>) -> <font color="#666666">int</font></tt></td><td class="a">sign (-1, 0, 1) of a float</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>sign</b>(x<font color="#666666">:vec_i</font>) -> <font color="#666666">vec_i</font></tt></td><td class="a">signs of an int vector</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>sign</b>(x<font color="#666666">:vec_f</font>) -> <font color="#666666">vec_i</font></tt></td><td class="a">signs of a float vector</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>min</b>(x<font color="#666666">:int</font>, y<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">smallest of 2 integers.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>min</b>(x<font color="#666666">:float</font>, y<font color="#666666">:float</font>) -> <font color="#666666">float</font></tt></td><td class="a">smallest of 2 floats.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>min</b>(x<font color="#666666">:vec_i</font>, y<font color="#666666">:vec_i</font>) -> <font color="#666666">vec_i</font></tt></td><td class="a">smallest components of 2 int vectors</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>min</b>(x<font color="#666666">:vec_f</font>, y<font color="#666666">:vec_f</font>) -> <font color="#666666">vec_f</font></tt></td><td class="a">smallest components of 2 float vectors</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>min</b>(v<font color="#666666">:vec_i</font>) -> <font color="#666666">int</font></tt></td><td class="a">smallest component of a int vector.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>min</b>(v<font color="#666666">:vec_f</font>) -> <font color="#666666">float</font></tt></td><td class="a">smallest component of a float vector.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>min</b>(v<font color="#666666">:[int]</font>) -> <font color="#666666">int</font></tt></td><td class="a">smallest component of a int vector, or INT_MAX if length 0.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>min</b>(v<font color="#666666">:[float]</font>) -> <font color="#666666">float</font></tt></td><td class="a">smallest component of a float vector, or FLT_MAX if length 0.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>max</b>(x<font color="#666666">:int</font>, y<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">largest of 2 integers.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>max</b>(x<font color="#666666">:float</font>, y<font color="#666666">:float</font>) -> <font color="#666666">float</font></tt></td><td class="a">largest of 2 floats.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>max</b>(x<font color="#666666">:vec_i</font>, y<font color="#666666">:vec_i</font>) -> <font color="#666666">vec_i</font></tt></td><td class="a">largest components of 2 int vectors</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>max</b>(x<font color="#666666">:vec_f</font>, y<font color="#666666">:vec_f</font>) -> <font color="#666666">vec_f</font></tt></td><td class="a">largest components of 2 float vectors</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>max</b>(v<font color="#666666">:vec_i</font>) -> <font color="#666666">int</font></tt></td><td class="a">largest component of a int vector.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>max</b>(v<font color="#666666">:vec_f</font>) -> <font color="#666666">float</font></tt></td><td class="a">largest component of a float vector.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>max</b>(v<font color="#666666">:[int]</font>) -> <font color="#666666">int</font></tt></td><td class="a">largest component of a int vector, or INT_MIN if length 0.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>max</b>(v<font color="#666666">:[float]</font>) -> <font color="#666666">float</font></tt></td><td class="a">largest component of a float vector, or FLT_MIN if length 0.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>lerp</b>(x<font color="#666666">:float</font>, y<font color="#666666">:float</font>, f<font color="#666666">:float</font>) -> <font color="#666666">float</font></tt></td><td class="a">linearly interpolates between x and y with factor f [0..1]</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>lerp</b>(a<font color="#666666">:vec_f</font>, b<font color="#666666">:vec_f</font>, f<font color="#666666">:float</font>) -> <font color="#666666">vec_f</font></tt></td><td class="a">linearly interpolates between a and b vectors with factor f [0..1]</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>smoothmin</b>(x<font color="#666666">:float</font>, y<font color="#666666">:float</font>, k<font color="#666666">:float</font>) -> <font color="#666666">float</font></tt></td><td class="a">k is the influence range</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>smoothstep</b>(x<font color="#666666">:float</font>) -> <font color="#666666">float</font></tt></td><td class="a">input must be in range 0..1, https://en.wikipedia.org/wiki/Smoothstep</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>smoothstep</b>(a<font color="#666666">:float</font>, b<font color="#666666">:float</font>, f<font color="#666666">:float</font>) -> <font color="#666666">float</font></tt></td><td class="a">hermite interpolation between a and b by f [0..1], https://registry.khronos.org/OpenGL-Refpages/gl4/html/smoothstep.xhtml</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>smootherstep</b>(x<font color="#666666">:float</font>) -> <font color="#666666">float</font></tt></td><td class="a">input must be in range 0..1, https://en.wikipedia.org/wiki/Smoothstep</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>cardinal_spline</b>(z<font color="#666666">:vec_f</font>, a<font color="#666666">:vec_f</font>, b<font color="#666666">:vec_f</font>, c<font color="#666666">:vec_f</font>, f<font color="#666666">:float</font>, tension<font color="#666666">:float</font>) -> <font color="#666666">vec_f</font></tt></td><td class="a">computes the position between a and b with factor f [0..1], using z (before a) and c (after b) to form a cardinal spline (tension at 0.5 is a good default)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>line_intersect</b>(line1a<font color="#666666">:float2</font>, line1b<font color="#666666">:float2</font>, line2a<font color="#666666">:float2</font>, line2b<font color="#666666">:float2</font>) -> <font color="#666666">int</font>, <font color="#666666">float2</font></tt></td><td class="a">computes if there is an intersection point between 2 line segments, with the point as second return value</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>circles_within_range</b>(dist<font color="#666666">:float</font>, positions<font color="#666666">:[float2]</font>, radiuses<font color="#666666">:[float]</font>, positions2<font color="#666666">:[float2]</font>, radiuses2<font color="#666666">:[float]</font>, gridsize<font color="#666666">:int2</font>) -> <font color="#666666">[[int]]</font></tt></td><td class="a">Given a vector of 2D positions (and same size vectors of radiuses), returns a vector of vectors of indices (to the second set of positions and radiuses) of the circles that are within dist of eachothers radius. If the second set are [], the first set is used for both (and the self element is excluded). gridsize optionally specifies the size of the grid to use for accellerated lookup of nearby points. This is essential for the algorithm to be fast, too big or too small can cause slowdown. Omit it, and a heuristic will be chosen for you, which is currently sqrt(num_circles) * 2 along each dimension, e.g. 100 elements would use a 20x20 grid. Efficiency wise this algorithm is fastest if there is not too much variance in the radiuses of the second set and/or the second set has smaller radiuses than the first.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>wave_function_collapse</b>(tilemap<font color="#666666">:[string]</font>, size<font color="#666666">:int2</font>) -> <font color="#666666">[string]</font>, <font color="#666666">int</font></tt></td><td class="a">returns a tilemap of given size modelled after the possible shapes in the input tilemap. Tilemap should consist of chars in the 0..127 range. Second return value the number of failed neighbor matches, this should ideally be 0, but can be non-0 for larger maps. Simply call this function repeatedly until it is 0</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>hash</b>(x<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">hashes an int value into a positive int; may be the identity function</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>hash</b>(x<font color="#666666"></font>) -> <font color="#666666">int</font></tt></td><td class="a">hashes any ref value into a positive int</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>hash</b>(x<font color="#666666">:function</font>) -> <font color="#666666">int</font></tt></td><td class="a">hashes a function value into a positive int</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>hash</b>(x<font color="#666666">:float</font>) -> <font color="#666666">int</font></tt></td><td class="a">hashes a float value into a positive int</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>hash</b>(v<font color="#666666">:vec_i</font>) -> <font color="#666666">int</font></tt></td><td class="a">hashes a int vector into a positive int</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>hash</b>(v<font color="#666666">:vec_f</font>) -> <font color="#666666">int</font></tt></td><td class="a">hashes a float vector into a positive int</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>call_function_value</b>(x<font color="#666666">:function</font>)</tt></td><td class="a">calls a void / no args function value.. you shouldn't need to use this, it is a demonstration of how native code can call back into Lobster</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>type_string</b>(ref<font color="#666666"></font>) -> <font color="#666666">string</font></tt></td><td class="a">string representing the type of the given reference (object/vector/string/resource)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>type_element_string</b>(v<font color="#666666">:[any]</font>) -> <font color="#666666">string</font></tt></td><td class="a">string representing the type of the elements of a vector</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>type_field_count</b>(obj<font color="#666666"></font>) -> <font color="#666666">int</font></tt></td><td class="a">number of fields in an object, or 0 for other reference types</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>type_field_string</b>(obj<font color="#666666"></font>, idx<font color="#666666">:int</font>) -> <font color="#666666">string</font></tt></td><td class="a">string representing the type of a field in an object, or empty for other reference types</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>type_field_name</b>(obj<font color="#666666"></font>, idx<font color="#666666">:int</font>) -> <font color="#666666">string</font></tt></td><td class="a">name of a field in an object, or empty for other reference types</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>type_field_value</b>(obj<font color="#666666"></font>, idx<font color="#666666">:int</font>) -> <font color="#666666">string</font></tt></td><td class="a">string representing the value of a field in an object, or empty for other reference types</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>program_name</b>() -> <font color="#666666">string</font></tt></td><td class="a">returns the name of the main program (e.g. "foo.lobster"), "" if running from lpak.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>vm_compiled_mode</b>() -> <font color="#666666">int</font></tt></td><td class="a">returns if the VM is running in compiled mode (Lobster -&gt; C++), or false for JIT.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>seconds_elapsed</b>() -> <font color="#666666">float</font></tt></td><td class="a">seconds since program start as a float, unlike gl_time() it is calculated every time it is called</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>date_time</b>(utc<font color="#666666">:bool</font> = false) -> <font color="#666666">[int]</font></tt></td><td class="a">a vector of integers representing date &amp; time information (index with date_time.lobster). By default returns local time, pass true for UTC instead.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>date_time_string</b>(utc<font color="#666666">:bool</font> = false) -> <font color="#666666">string</font></tt></td><td class="a">a string representing date &amp; time information in the format: 'Www Mmm dd hh:mm:ss yyyy'. By default returns local time, pass true for UTC instead.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>date_time_string_format</b>(format<font color="#666666">:string</font>, utc<font color="#666666">:bool</font> = false) -> <font color="#666666">string</font></tt></td><td class="a">a string representing date &amp; time information using a formatting string according to https://en.cppreference.com/w/cpp/chrono/c/strftime, for example "%Y_%m_%d_%H_%M_%S". By default returns local time, pass true for UTC instead.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>assert</b>(condition<font color="#666666"></font>) -> <font color="#666666">any</font></tt></td><td class="a">halts the program with an assertion failure if passed false. returns its input. runtime errors like this will contain a stack trace if --runtime-verbose is on.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>get_stack_trace</b>() -> <font color="#666666">string</font></tt></td><td class="a">gets a stack trace of the current location of the program (needs --runtime-verbose) without actually stopping the program.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>get_memory_usage</b>(n<font color="#666666">:int</font>) -> <font color="#666666">string</font></tt></td><td class="a">gets a text showing the top n object types that are using the most memory.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>pass</b>()</tt></td><td class="a">does nothing. useful for empty bodies of control structures.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>trace_bytecode</b>(mode<font color="#666666">:int</font>)</tt></td><td class="a">tracing shows each bytecode instruction as it is being executed, not very useful unless you are trying to isolate a compiler bug. Mode is off(0), on(1) or tail only (2)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>reference_count</b>(val<font color="#666666"></font>) -> <font color="#666666">int</font></tt></td><td class="a">get the reference count of any value. for compiler debugging, mostly</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>set_console</b>(on<font color="#666666">:bool</font>)</tt></td><td class="a">lets you turn on/off the console window (on Windows)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>set_output_level</b>(level<font color="#666666">:int</font>)</tt></td><td class="a">0 = debug, 1 = verbose, 2 = warn (default), 3 = error, 4 = program</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>set_exit_code</b>(code<font color="#666666">:int</font>)</tt></td><td class="a">this will be returned when run as a console application</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>command_line_arguments</b>() -> <font color="#666666">[string]</font></tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>thread_information</b>() -> <font color="#666666">int</font>, <font color="#666666">int</font></tt></td><td class="a">returns the number of hardware threads, and the number of cores</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>is_worker_thread</b>() -> <font color="#666666">int</font></tt></td><td class="a">whether the current thread is a worker thread</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>start_worker_threads</b>(numthreads<font color="#666666">:int</font>)</tt></td><td class="a">launch worker threads</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>stop_worker_threads</b>()</tt></td><td class="a">only needs to be called if you want to stop the worker threads before the end of the program, or if you want to call start_worker_threads again. workers_alive will become false inside the workers, which should then exit.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>workers_alive</b>() -> <font color="#666666">int</font></tt></td><td class="a">whether workers should continue doing work. returns false after stop_worker_threads() has been called.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>thread_write</b>(struct<font color="#666666"></font>)</tt></td><td class="a">put this struct in the thread queue</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>thread_read</b>(type<font color="#666666">:typeid(any)</font>) -> <font color="#666666">any?</font></tt></td><td class="a">get a struct from the thread queue. pass the typeof struct. blocks if no suchstructs available. returns struct, or nil if stop_worker_threads() was called</td></tr>
</table>
<h3>compiler</h3>
<table class="a" border=1 cellspacing=0 cellpadding=4>
<tr class="a" valign=top><td class="a"><tt><b>compile_run_code</b>(code<font color="#666666">:string</font>, args<font color="#666666">:[string]</font>) -> <font color="#666666">string</font>, <font color="#666666">string?</font></tt></td><td class="a">compiles and runs lobster source, sandboxed from the current program (in its own VM). the argument is a string of code. returns the return value of the program as a string, with an error string as second return value, or nil if none. using parse_data(), two program can communicate more complex data structures even if they don't have the same version of struct definitions.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>compile_run_file</b>(filename<font color="#666666">:string</font>, args<font color="#666666">:[string]</font>) -> <font color="#666666">string</font>, <font color="#666666">string?</font></tt></td><td class="a">same as compile_run_code(), only now you pass a filename.</td></tr>
</table>
<h3>file</h3>
<table class="a" border=1 cellspacing=0 cellpadding=4>
<tr class="a" valign=top><td class="a"><tt><b>scan_folder</b>(folder<font color="#666666">:string</font>, rel<font color="#666666">:bool</font> = false) -> <font color="#666666">[string]?</font>, <font color="#666666">[int]?</font></tt></td><td class="a">returns two vectors representing all elements in a folder, the first vector containing all names, the second vector containing sizes in bytes (or -1 if a directory). set rel use a relative path, default is absolute. Returns nil if folder couldn't be scanned.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>read_file</b>(file<font color="#666666">:string</font>, textmode<font color="#666666">:int</font> = 0) -> <font color="#666666">string?</font></tt></td><td class="a">returns the contents of a file as a string, or nil if the file can't be found. you may use either \ or / as path separators</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>write_file</b>(file<font color="#666666">:string</font>, contents<font color="#666666">:string</font>, textmode<font color="#666666">:int</font> = 0, absolute_path<font color="#666666">:int</font> = 0) -> <font color="#666666">int</font></tt></td><td class="a">creates a file with the contents of a string, returns false if writing wasn't possible</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>rename_file</b>(old_file<font color="#666666">:string</font>, new_file<font color="#666666">:string</font>) -> <font color="#666666">int</font></tt></td><td class="a">renames a file, returns false if it wasn't possible</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>delete_file</b>(file<font color="#666666">:string</font>) -> <font color="#666666">int</font></tt></td><td class="a">deletes a file, returns false if it wasn't possible. Will search in all import dirs.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>exists_file</b>(file<font color="#666666">:string</font>) -> <font color="#666666">int</font></tt></td><td class="a">checks wether a file exists.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>launch_subprocess</b>(commandline<font color="#666666">:[string]</font>, stdin<font color="#666666">:string</font> = nil) -> <font color="#666666">int</font>, <font color="#666666">string</font></tt></td><td class="a">launches a sub process, with optionally a stdin for the process, and returns its return code (or -1 if it couldn't launch at all), and any output</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>vector_to_buffer</b>(vec<font color="#666666">:[any]</font>, width<font color="#666666">:int</font> = 4) -> <font color="#666666">string</font></tt></td><td class="a">converts a vector of ints/floats (or structs of them) to a buffer, where each scalar is written with "width" bytes (1/2/4/8, default 4). Returns nil if the type couldn't be converted. Uses native endianness.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>ensure_size</b>(string<font color="#666666">:string</font>, size<font color="#666666">:int</font>, char<font color="#666666">:int</font>, extra<font color="#666666">:int</font> = 0) -> <font color="#666666">string</font></tt></td><td class="a">ensures a string is at least size characters. if it is, just returns the existing string, otherwise returns a new string of that size (with optionally extra bytes added), with any new characters set to char. You can specify a negative size to mean relative to the end, i.e. new characters will be added at the start. </td></tr>
<tr class="a" valign=top><td class="a"><tt><b>write_int64_le</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>, val<font color="#666666">:int</font>) -> <font color="#666666">string</font>, <font color="#666666">int</font></tt></td><td class="a">writes a value as little endian to a string at location i. Uses ensure_size to make the string twice as long (with extra 0 bytes) if no space. Returns new string if resized, and the index of the location right after where the value was written. The _back version writes relative to the end (and writes before the index)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>write_int32_le</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>, val<font color="#666666">:int</font>) -> <font color="#666666">string</font>, <font color="#666666">int</font></tt></td><td class="a">(see write_int64_le)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>write_int16_le</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>, val<font color="#666666">:int</font>) -> <font color="#666666">string</font>, <font color="#666666">int</font></tt></td><td class="a">(see write_int64_le)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>write_int8_le</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>, val<font color="#666666">:int</font>) -> <font color="#666666">string</font>, <font color="#666666">int</font></tt></td><td class="a">(see write_int64_le)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>write_float64_le</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>, val<font color="#666666">:float</font>) -> <font color="#666666">string</font>, <font color="#666666">int</font></tt></td><td class="a">(see write_int64_le)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>write_float32_le</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>, val<font color="#666666">:float</font>) -> <font color="#666666">string</font>, <font color="#666666">int</font></tt></td><td class="a">(see write_int64_le)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>write_int64_le_back</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>, val<font color="#666666">:int</font>) -> <font color="#666666">string</font>, <font color="#666666">int</font></tt></td><td class="a">(see write_int64_le)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>write_int32_le_back</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>, val<font color="#666666">:int</font>) -> <font color="#666666">string</font>, <font color="#666666">int</font></tt></td><td class="a">(see write_int64_le)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>write_int16_le_back</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>, val<font color="#666666">:int</font>) -> <font color="#666666">string</font>, <font color="#666666">int</font></tt></td><td class="a">(see write_int64_le)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>write_int8_le_back</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>, val<font color="#666666">:int</font>) -> <font color="#666666">string</font>, <font color="#666666">int</font></tt></td><td class="a">(see write_int64_le)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>write_float64_le_back</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>, val<font color="#666666">:float</font>) -> <font color="#666666">string</font>, <font color="#666666">int</font></tt></td><td class="a">(see write_int64_le)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>write_float32_le_back</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>, val<font color="#666666">:float</font>) -> <font color="#666666">string</font>, <font color="#666666">int</font></tt></td><td class="a">(see write_int64_le)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>write_substring</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>, substr<font color="#666666">:string</font>, nullterm<font color="#666666">:int</font>) -> <font color="#666666">string</font>, <font color="#666666">int</font></tt></td><td class="a">writes a substring into another string at i (see also write_int64_le)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>write_substring_back</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>, substr<font color="#666666">:string</font>, nullterm<font color="#666666">:int</font>) -> <font color="#666666">string</font>, <font color="#666666">int</font></tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>compare_substring</b>(string_a<font color="#666666">:string</font>, i_a<font color="#666666">:int</font>, string_b<font color="#666666">:string</font>, i_b<font color="#666666">:int</font>, len<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">returns if the two substrings are equal (0), or a &lt; b (-1) or a &gt; b (1).</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>read_int64_le</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>) -> <font color="#666666">int</font>, <font color="#666666">int</font></tt></td><td class="a">reads a value as little endian from a string at location i. The value must be within bounds of the string. Returns the value, and the index of the location right after where the value was read. The _back version reads relative to the end (and reads before the index)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>read_int32_le</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>) -> <font color="#666666">int</font>, <font color="#666666">int</font></tt></td><td class="a">(see read_int64_le)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>read_int16_le</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>) -> <font color="#666666">int</font>, <font color="#666666">int</font></tt></td><td class="a">(see read_int64_le)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>read_int8_le</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>) -> <font color="#666666">int</font>, <font color="#666666">int</font></tt></td><td class="a">(see read_int64_le)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>read_uint64_le</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>) -> <font color="#666666">int</font>, <font color="#666666">int</font></tt></td><td class="a">reads a value as little endian from a string at location i. The value must be within bounds of the string. Returns the value, and the index of the location right after where the value was read. The _back version reads relative to the end (and reads before the index)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>read_uint32_le</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>) -> <font color="#666666">int</font>, <font color="#666666">int</font></tt></td><td class="a">(see read_int64_le)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>read_uint16_le</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>) -> <font color="#666666">int</font>, <font color="#666666">int</font></tt></td><td class="a">(see read_int64_le)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>read_uint8_le</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>) -> <font color="#666666">int</font>, <font color="#666666">int</font></tt></td><td class="a">(see read_int64_le)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>read_float64_le</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>) -> <font color="#666666">float</font>, <font color="#666666">int</font></tt></td><td class="a">(see read_int64_le)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>read_float32_le</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>) -> <font color="#666666">float</font>, <font color="#666666">int</font></tt></td><td class="a">(see read_int64_le)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>read_int64_le_back</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>) -> <font color="#666666">int</font>, <font color="#666666">int</font></tt></td><td class="a">(see read_int64_le)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>read_int32_le_back</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>) -> <font color="#666666">int</font>, <font color="#666666">int</font></tt></td><td class="a">(see read_int64_le)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>read_int16_le_back</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>) -> <font color="#666666">int</font>, <font color="#666666">int</font></tt></td><td class="a">(see read_int64_le)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>read_int8_le_back</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>) -> <font color="#666666">int</font>, <font color="#666666">int</font></tt></td><td class="a">(see read_int64_le)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>read_uint64_le_back</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>) -> <font color="#666666">int</font>, <font color="#666666">int</font></tt></td><td class="a">(see read_int64_le)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>read_uint32_le_back</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>) -> <font color="#666666">int</font>, <font color="#666666">int</font></tt></td><td class="a">(see read_int64_le)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>read_uint16_le_back</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>) -> <font color="#666666">int</font>, <font color="#666666">int</font></tt></td><td class="a">(see read_int64_le)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>read_uint8_le_back</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>) -> <font color="#666666">int</font>, <font color="#666666">int</font></tt></td><td class="a">(see read_int64_le)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>read_float64_le_back</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>) -> <font color="#666666">float</font>, <font color="#666666">int</font></tt></td><td class="a">(see read_int64_le)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>read_float32_le_back</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>) -> <font color="#666666">float</font>, <font color="#666666">int</font></tt></td><td class="a">(see read_int64_le)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>flatbuffers_field_int64</b>(string<font color="#666666">:string</font>, tablei<font color="#666666">:int</font>, vo<font color="#666666">:int</font>, def<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">reads a flatbuffers field from a string at table location tablei, field vtable offset vo, and default value def. The value must be within bounds of the string. Returns the value (or default if the field was not present)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>flatbuffers_field_int32</b>(string<font color="#666666">:string</font>, tablei<font color="#666666">:int</font>, vo<font color="#666666">:int</font>, def<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">(see flatbuffers_field_int64)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>flatbuffers_field_int16</b>(string<font color="#666666">:string</font>, tablei<font color="#666666">:int</font>, vo<font color="#666666">:int</font>, def<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">(see flatbuffers_field_int64)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>flatbuffers_field_int8</b>(string<font color="#666666">:string</font>, tablei<font color="#666666">:int</font>, vo<font color="#666666">:int</font>, def<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">(see flatbuffers_field_int64)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>flatbuffers_field_uint64</b>(string<font color="#666666">:string</font>, tablei<font color="#666666">:int</font>, vo<font color="#666666">:int</font>, def<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">reads a flatbuffers field from a string at table location tablei, field vtable offset vo, and default value def. The value must be within bounds of the string. Returns the value (or default if the field was not present)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>flatbuffers_field_uint32</b>(string<font color="#666666">:string</font>, tablei<font color="#666666">:int</font>, vo<font color="#666666">:int</font>, def<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">(see flatbuffers_field_int64)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>flatbuffers_field_uint16</b>(string<font color="#666666">:string</font>, tablei<font color="#666666">:int</font>, vo<font color="#666666">:int</font>, def<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">(see flatbuffers_field_int64)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>flatbuffers_field_uint8</b>(string<font color="#666666">:string</font>, tablei<font color="#666666">:int</font>, vo<font color="#666666">:int</font>, def<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">(see flatbuffers_field_int64)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>flatbuffers_field_float64</b>(string<font color="#666666">:string</font>, tablei<font color="#666666">:int</font>, vo<font color="#666666">:int</font>, def<font color="#666666">:float</font>) -> <font color="#666666">float</font></tt></td><td class="a">(see flatbuffers_field_int64)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>flatbuffers_field_float32</b>(string<font color="#666666">:string</font>, tablei<font color="#666666">:int</font>, vo<font color="#666666">:int</font>, def<font color="#666666">:float</font>) -> <font color="#666666">float</font></tt></td><td class="a">(see flatbuffers_field_int64)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>flatbuffers_field_string</b>(string<font color="#666666">:string</font>, tablei<font color="#666666">:int</font>, vo<font color="#666666">:int</font>) -> <font color="#666666">string</font></tt></td><td class="a">reads a flatbuffer string field, returns "" if not present</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>flatbuffers_field_vector_len</b>(string<font color="#666666">:string</font>, tablei<font color="#666666">:int</font>, vo<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">reads a flatbuffer vector field length, or 0 if not present</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>flatbuffers_field_vector</b>(string<font color="#666666">:string</font>, tablei<font color="#666666">:int</font>, vo<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">returns a flatbuffer vector field element start, or 0 if not present</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>flatbuffers_field_table</b>(string<font color="#666666">:string</font>, tablei<font color="#666666">:int</font>, vo<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">returns a flatbuffer table field start, or 0 if not present</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>flatbuffers_field_struct</b>(string<font color="#666666">:string</font>, tablei<font color="#666666">:int</font>, vo<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">returns a flatbuffer struct field start, or 0 if not present</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>flatbuffers_field_present</b>(string<font color="#666666">:string</font>, tablei<font color="#666666">:int</font>, vo<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">returns if a flatbuffer field is present (unequal to default)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>flatbuffers_indirect</b>(string<font color="#666666">:string</font>, index<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">returns a flatbuffer offset at index relative to itself</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>flatbuffers_string</b>(string<font color="#666666">:string</font>, index<font color="#666666">:int</font>) -> <font color="#666666">string</font></tt></td><td class="a">returns a flatbuffer string whose offset is at given index</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>flatbuffers_binary_to_json</b>(schemas<font color="#666666">:string</font>, binary<font color="#666666">:string</font>, includedirs<font color="#666666">:[string]</font>) -> <font color="#666666">string</font>, <font color="#666666">string?</font></tt></td><td class="a">returns a JSON string generated from the given binary and corresponding schema.if there was an error parsing the schema, the error will be in the second returnvalue, or nil for no error</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>flatbuffers_json_to_binary</b>(schema<font color="#666666">:string</font>, json<font color="#666666">:string</font>, includedirs<font color="#666666">:[string]</font>) -> <font color="#666666">string</font>, <font color="#666666">string?</font></tt></td><td class="a">returns a binary flatbuffer generated from the given json and corresponding schema.if there was an error parsing the schema, the error will be in the second returnvalue, or nil for no error</td></tr>
</table>
<h3>parsedata</h3>
<table class="a" border=1 cellspacing=0 cellpadding=4>
<tr class="a" valign=top><td class="a"><tt><b>parse_data</b>(typeid<font color="#666666">:typeid(any)</font>, stringdata<font color="#666666">:string</font>) -> <font color="#666666">any?</font>, <font color="#666666">string?</font></tt></td><td class="a">parses a string containing a data structure in lobster syntax (what you get if you convert an arbitrary data structure to a string) back into a data structure. supports int/float/string/vector and classes. classes will be forced to be compatible with their  current definitions, i.e. too many elements will be truncated, missing elements will be set to 0/nil if possible. useful for simple file formats. returns the value and an error string as second return value (or nil if no error)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>flexbuffers_value_to_binary</b>(val<font color="#666666"></font>, max_nesting<font color="#666666">:int</font> = 0, cycle_detection<font color="#666666">:bool</font> = false) -> <font color="#666666">string</font></tt></td><td class="a">turns any reference value into a flexbuffer. max_nesting defaults to 100. cycle_detection is by default off (expensive)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>flexbuffers_binary_to_value</b>(typeid<font color="#666666">:typeid(any)</font>, flex<font color="#666666">:string</font>) -> <font color="#666666">any?</font>, <font color="#666666">string?</font></tt></td><td class="a">turns a flexbuffer into a value</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>flexbuffers_binary_to_json</b>(flex<font color="#666666">:string</font>, field_quotes<font color="#666666">:bool</font>, indent_string<font color="#666666">:string</font>) -> <font color="#666666">string?</font>, <font color="#666666">string?</font></tt></td><td class="a">turns a flexbuffer into a JSON string. If indent_string is empty, will be a single line string</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>flexbuffers_json_to_binary</b>(json<font color="#666666">:string</font>) -> <font color="#666666">string</font>, <font color="#666666">string?</font></tt></td><td class="a">turns a JSON string into a flexbuffer, second value is error, if any</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>lobster_value_to_binary</b>(val<font color="#666666"></font>) -> <font color="#666666">string</font></tt></td><td class="a">turns any reference value into a binary using a fast &amp; compact Lobster native serialization format. this is intended for threads/networking, not for storage (since it is not readable by other languages). data structures participating must have been marked by attribute serializable. does not provide protection against cycles, use flexbuffers if that is a concern. </td></tr>
<tr class="a" valign=top><td class="a"><tt><b>lobster_binary_to_value</b>(typeid<font color="#666666">:typeid(any)</font>, bin<font color="#666666">:string</font>) -> <font color="#666666">any?</font>, <font color="#666666">string?</font></tt></td><td class="a">turns binary created by lobster_value_to_binary back into a value</td></tr>
</table>
<h3>matrix</h3>
<table class="a" border=1 cellspacing=0 cellpadding=4>
<tr class="a" valign=top><td class="a"><tt><b>matrix_multiply</b>(a<font color="#666666">:[float]</font>, b<font color="#666666">:[float]</font>) -> <font color="#666666">[float]</font></tt></td><td class="a">input matrices must be 4x4 elements</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>matrix_rotate_x</b>(angle<font color="#666666">:float2</font>) -> <font color="#666666">[float]</font></tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>matrix_rotate_y</b>(angle<font color="#666666">:float2</font>) -> <font color="#666666">[float]</font></tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>matrix_rotate_z</b>(angle<font color="#666666">:float2</font>) -> <font color="#666666">[float]</font></tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>matrix_translation</b>(trans<font color="#666666">:float3</font>) -> <font color="#666666">[float]</font></tt></td><td class="a"></td></tr>
</table>
<h3>graphics</h3>
<table class="a" border=1 cellspacing=0 cellpadding=4>
<tr class="a" valign=top><td class="a"><tt><b>gl_window</b>(title<font color="#666666">:string</font>, xs<font color="#666666">:int</font>, ys<font color="#666666">:int</font>, flags<font color="#666666">:int</font> = 0, samples<font color="#666666">:int</font> = 1) -> <font color="#666666">string?</font></tt></td><td class="a">opens a window for OpenGL rendering. returns error string if any problems, nil otherwise. For flags, see modules/gl.lobster</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_require_version</b>(major<font color="#666666">:int</font>, minor<font color="#666666">:int</font>)</tt></td><td class="a">Call this before gl_window to request a certain version of OpenGL context. Currently only works on win/nix, minimum is 3.2.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_load_materials</b>(materialdefs<font color="#666666">:string</font>, inline<font color="#666666">:int</font> = 0) -> <font color="#666666">string?</font></tt></td><td class="a">loads an additional materials file (data/shaders/default.materials is already loaded by default by gl_window()). if inline is true, materialdefs is not a filename, but the actual materials. returns error string if any problems, nil otherwise.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_scissor</b>(top_left<font color="#666666">:int2</font>, size<font color="#666666">:int2</font>) -> <font color="#666666">int2</font>, <font color="#666666">int2</font></tt></td><td class="a">Sets the scissor testing, so only the pixels in the given rectangle canbe written.  Returns the previous value of the scissor rectangle.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_frame</b>() -> <font color="#666666">int</font></tt></td><td class="a">advances rendering by one frame, swaps buffers, and collects new input events. returns false if the closebutton on the window was pressed</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_shutdown</b>()</tt></td><td class="a">shuts down the OpenGL window. you only need to call this function if you wish to close it before the end of the program</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_window_title</b>(title<font color="#666666">:string</font>) -> <font color="#666666">string</font></tt></td><td class="a">changes the window title.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_window_min_max</b>(dir<font color="#666666">:int</font>)</tt></td><td class="a">&gt;0 to maximize, &lt;0 to minimize or 0 to restore.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_fullscreen</b>(mode<font color="#666666">:int</font>)</tt></td><td class="a">0: window, 1:fullscreen, 2:borderless</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_visible</b>() -> <font color="#666666">int</font></tt></td><td class="a">checks if the window is currently visible (not minimized, or on mobile devices, in the foreground). If false, you should not render anything, nor run the frame's code.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_cursor</b>(on<font color="#666666">:bool</font>) -> <font color="#666666">int</font></tt></td><td class="a">default the cursor is visible, turn off for implementing FPS like control schemes. return whether it's on.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_grab</b>(on<font color="#666666">:bool</font>) -> <font color="#666666">int</font></tt></td><td class="a">grabs the mouse when the window is active. return whether it's on.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_button</b>(name<font color="#666666">:string</font>) -> <font color="#666666">int</font>, <font color="#666666">int</font></tt></td><td class="a">returns the number of frames a key/mousebutton/finger has been down. went down this frame: == 1, is already down: &gt;= 1, not down: == 0. the second return value is the same, but for the up direction: went up this frame: == 1, is already up: &gt;= 1, not up: == 0. it is possible both happen inside one frame, i.e. down==1 and up==1!  for name, pass a string like mouse1/mouse2/mouse3/escape/space/up/down/a/b/f1/joy1 etc. mouse11 and on are additional fingers</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_key_repeat</b>(name<font color="#666666">:string</font>) -> <font color="#666666">int</font></tt></td><td class="a">returns if a key was a key repeat (went down, or is down with a key repeat)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_start_text_input</b>(pos<font color="#666666">:int2</font>, size<font color="#666666">:int2</font>)</tt></td><td class="a">starts text input. unlike gl_button which gets you keyboard keys, this is for input of strings, that can deal with unicode IME etc. pos &amp; size are a hint where the string being edited is being displayed, such that an IME can popup a box next to it, if needed.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_text_input_state</b>() -> <font color="#666666">string</font>, <font color="#666666">string</font>, <font color="#666666">int</font>, <font color="#666666">int</font></tt></td><td class="a">returns the string that has been input since text input started, followed by any candinate text (partial characters in case of IME editing), and the cursor &amp; selection size for it</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_set_text_input</b>(text<font color="#666666">:string</font>)</tt></td><td class="a">overwrites the current text string being accumulated</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_end_text_input</b>()</tt></td><td class="a">stops accumulating text input</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_touchscreen</b>() -> <font color="#666666">int</font></tt></td><td class="a">whether a you're getting input from a touch screen (as opposed to mouse &amp; keyboard)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_dpi</b>(screen<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">the DPI of the screen. always returns a value for screen 0, any other screens may return 0 to indicate the screen doesn't exist</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_window_size</b>() -> <font color="#666666">int2</font></tt></td><td class="a">a vector representing the size (in pixels) of the window, changes when the user resizes</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_mouse_pos</b>(i<font color="#666666">:int</font>) -> <font color="#666666">int2</font></tt></td><td class="a">the current mouse/finger position in pixels, pass a value other than 0 to read additional fingers (for touch screens only if the corresponding gl_isdown is true)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_mouse_delta</b>(i<font color="#666666">:int</font>) -> <font color="#666666">int2</font></tt></td><td class="a">number of pixels the mouse/finger has moved since the last frame. use this instead of substracting positions to correctly deal with lifted fingers and FPS mode (gl_cursor(0))</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_local_mouse_pos</b>(i<font color="#666666">:int</font>) -> <font color="#666666">float2</font></tt></td><td class="a">the current mouse/finger position local to the current transform (gl_translate etc) (for touch screens only if the corresponding gl_isdown is true)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_last_pos</b>(name<font color="#666666">:string</font>, down<font color="#666666">:int</font>) -> <font color="#666666">int2</font></tt></td><td class="a">position (in pixels) key/mousebutton/finger last went down (true) or up (false)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_local_last_pos</b>(name<font color="#666666">:string</font>, down<font color="#666666">:int</font>) -> <font color="#666666">float2</font></tt></td><td class="a">position (local to the current transform) key/mousebutton/finger last went down (true) or up (false)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_mousewheel_delta</b>() -> <font color="#666666">int</font></tt></td><td class="a">amount the mousewheel scrolled this frame, in number of notches</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_joy_axis</b>(i<font color="#666666">:int</font>) -> <font color="#666666">float</font></tt></td><td class="a">the current joystick orientation for axis i, as -1 to 1 value</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_delta_time</b>() -> <font color="#666666">float</font></tt></td><td class="a">seconds since the last frame, updated only once per frame</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_time</b>() -> <font color="#666666">float</font></tt></td><td class="a">seconds since the start of the OpenGL subsystem, updated only once per frame (use seconds_elapsed() for continuous timing)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_last_time</b>(name<font color="#666666">:string</font>, down<font color="#666666">:int</font>) -> <font color="#666666">float</font></tt></td><td class="a">time key/mousebutton/finger last went down (true) or up (false)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_clear</b>(col<font color="#666666">:float4</font>)</tt></td><td class="a">clears the framebuffer (and depth buffer) to the given color</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_color</b>(col<font color="#666666">:float4</font>) -> <font color="#666666">float4</font></tt></td><td class="a">sets the current color, returns previous one</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_polygon</b>(vertlist<font color="#666666">:[vec_f]</font>)</tt></td><td class="a">renders a polygon using the list of points given. warning: gl_polygon creates a new mesh every time, gl_new_poly/gl_render_mesh is faster.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_rounded_rectangle</b>(size<font color="#666666">:float2</font>, segments<font color="#666666">:int</font>, corner_ratio<font color="#666666">:float</font>)</tt></td><td class="a">renders a rounded rectangle, try segments 50, corner_ratio 0.2</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_circle</b>(radius<font color="#666666">:float</font>, segments<font color="#666666">:int</font>)</tt></td><td class="a">renders a circle</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_open_circle</b>(radius<font color="#666666">:float</font>, segments<font color="#666666">:int</font>, thickness<font color="#666666">:float</font>)</tt></td><td class="a">renders a circle that is open on the inside. thickness is the fraction of the radius that is filled, try e.g. 0.2</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_unit_cube</b>(insideout<font color="#666666">:int</font> = 0)</tt></td><td class="a">renders a unit cube (0,0,0) - (1,1,1). optionally pass true to have it rendered inside out</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_rotate_x</b>(vec<font color="#666666">:float2</font>)</tt></td><td class="a">rotates the yz plane around the x axis, using a 2D vector normalized vector as angle</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_rotate_y</b>(angle<font color="#666666">:float2</font>)</tt></td><td class="a">rotates the xz plane around the y axis, using a 2D vector normalized vector as angle</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_rotate_z</b>(angle<font color="#666666">:float2</font>)</tt></td><td class="a">rotates the xy plane around the z axis (used in 2D), using a 2D vector normalized vector as angle</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_translate</b>(vec<font color="#666666">:vec_f</font>)</tt></td><td class="a">translates the current coordinate system along a vector</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_scale</b>(factor<font color="#666666">:float</font>)</tt></td><td class="a">scales the current coordinate system using a numerical factor</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_scale</b>(factor<font color="#666666">:vec_f</font>)</tt></td><td class="a">scales the current coordinate system using a vector</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_origin</b>() -> <font color="#666666">float2</font></tt></td><td class="a">returns a vector representing the current transform origin in pixels. only makes sense in 2D mode (no gl_perspective called).</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_scaling</b>() -> <font color="#666666">float2</font></tt></td><td class="a">returns a vector representing the current transform scale in pixels. only makes sense in 2D mode (no gl_perspective called).</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_model_view_projection</b>() -> <font color="#666666">[float]</font></tt></td><td class="a">returns a vector representing the current model view projection matrix (16 elements)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_model_view</b>() -> <font color="#666666">[float]</font></tt></td><td class="a">returns a vector representing the current model view matrix (16 elements)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_projection</b>() -> <font color="#666666">[float]</font></tt></td><td class="a">returns a vector representing the current projection matrix (16 elements)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_push_model_view</b>()</tt></td><td class="a">save the current state of the model view matrix (gl_translate, gl_rotate etc)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_pop_model_view</b>() -> <font color="#666666">int</font></tt></td><td class="a">restore a previous state of the model view matrix. returns false if none</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_point_scale</b>(factor<font color="#666666">:float</font>)</tt></td><td class="a">sets the current scaling factor for point sprites. this can be what the current gl_scale is, or different, depending on the desired visuals. the ideal size may also be FOV dependent.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_line_mode</b>(on<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">set line mode (true == on), returns previous mode</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_cull_front</b>(on<font color="#666666">:bool</font>) -> <font color="#666666">int</font></tt></td><td class="a">set culling front (true) or back (false), returns previous value.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_hit</b>(vec<font color="#666666">:vec_f</font>, i<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">whether the mouse/finger is inside of the rectangle specified in terms of the current transform (for touch screens only if the corresponding gl_isdown is true). Only true if the last rectangle for which gl_hit was true last frame is of the same size as this one (allows you to safely test in most cases of overlapping rendering)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_rect</b>(size<font color="#666666">:float2</font>, centered<font color="#666666">:int</font> = 0)</tt></td><td class="a">renders a rectangle (0,0)..(1,1) (or (-1,-1)..(1,1) when centered), scaled by the given size.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_rect_tc_col</b>(size<font color="#666666">:float2</font>, tc<font color="#666666">:float2</font>, tcsize<font color="#666666">:float2</font>, cols<font color="#666666">:[float4]</font>)</tt></td><td class="a">Like gl_rect renders a sized quad, but allows you to specify texture coordinates and optionally colors (empty list for all white). Slow.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_unit_square</b>(centered<font color="#666666">:int</font> = 0)</tt></td><td class="a">renders a square (0,0)..(1,1) (or (-1,-1)..(1,1) when centered)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_line</b>(start<font color="#666666">:vec_f</font>, end<font color="#666666">:vec_f</font>, thickness<font color="#666666">:float</font>)</tt></td><td class="a">renders a line with the given thickness</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_perspective</b>(fovy<font color="#666666">:float</font>, znear<font color="#666666">:float</font>, zfar<font color="#666666">:float</font>, frame_buffer_size<font color="#666666">:int2</font> = nil, frame_buffer_offset<font color="#666666">:int2</font> = nil, nodepth<font color="#666666">:int</font> = 0)</tt></td><td class="a">changes from 2D mode (default) to 3D right handed perspective mode with vertical fov (try 60), far plane (furthest you want to be able to render, try 1000) and near plane (try 1). Optionally specify a framebuffer size to override the current gl_framebuffer_size</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_ortho</b>(rh<font color="#666666">:int</font> = 0, depth<font color="#666666">:int</font> = 0)</tt></td><td class="a">changes back to 2D mode rendering with a coordinate system from (0,0) top-left to the screen size in pixels bottom right. this is the default at the start of a frame, use this call to get back to that after gl_perspective. Pass true to rh have (0,0) bottom-left instead. Pass true to depth to have depth testing/writing on.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_ortho3d</b>(center<font color="#666666">:float3</font>, extends<font color="#666666">:float3</font>)</tt></td><td class="a">sets a custom ortho projection as 3D projection.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_new_poly</b>(positions<font color="#666666">:[vec_f]</font>) -> <font color="#666666">resource&lt;mesh&gt;</font></tt></td><td class="a">creates a mesh out of a loop of points, much like gl_polygon. gl_line_mode determines how this gets drawn (fan or loop). automatically generates texcoords and normals. returns mesh id</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_new_mesh</b>(format<font color="#666666">:string</font>, positions<font color="#666666">:[float3]</font>, colors<font color="#666666">:[float4]</font>, normals<font color="#666666">:[float3]</font>, texcoords1<font color="#666666">:[float2]</font>, texcoords2<font color="#666666">:[float2]</font>, indices<font color="#666666">:[int]</font> = nil) -> <font color="#666666">resource&lt;mesh&gt;</font></tt></td><td class="a">creates a new vertex buffer and returns an integer id (1..) for it. format must be made up of characters P (position), C (color), T (texcoord), N (normal). indices may be []. positions is obligatory. you may specify [] for any of the other attributes if not required by format, or to get defaults for colors (white) / texcoords (position x &amp; y) / normals (generated from adjacent triangles).</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_new_mesh_iqm</b>(filename<font color="#666666">:string</font>) -> <font color="#666666">resource&lt;mesh&gt;?</font></tt></td><td class="a">load a .iqm file into a mesh, returns mesh or nil on failure to load.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_mesh_parts</b>(m<font color="#666666">:resource&lt;mesh&gt;</font>) -> <font color="#666666">[string]</font></tt></td><td class="a">returns an array of names of all parts of mesh m (names may be empty)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_mesh_size</b>(m<font color="#666666">:resource&lt;mesh&gt;</font>) -> <font color="#666666">int</font></tt></td><td class="a">returns the number of verts in this mesh</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_animate_mesh</b>(m<font color="#666666">:resource&lt;mesh&gt;</font>, frame<font color="#666666">:float</font>)</tt></td><td class="a">set the frame for animated mesh m</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_render_mesh</b>(m<font color="#666666">:resource&lt;mesh&gt;</font>)</tt></td><td class="a">renders the specified mesh</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_save_mesh</b>(m<font color="#666666">:resource&lt;mesh&gt;</font>, name<font color="#666666">:string</font>) -> <font color="#666666">int</font></tt></td><td class="a">saves the specified mesh to a file in the PLY format. useful if the mesh was generated procedurally. returns false if the file could not be written</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_mesh_pointsize</b>(m<font color="#666666">:resource&lt;mesh&gt;</font>, pointsize<font color="#666666">:float</font>)</tt></td><td class="a">sets the pointsize for this mesh. the mesh must have been created with indices = nil for point rendering to be used. you also want to use a shader that works with points, such as color_attr_particle.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_set_shader</b>(shader<font color="#666666">:string</font>)</tt></td><td class="a">changes the current shader. shaders must reside in the shaders folder, builtin ones are: color / textured / phong</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_set_shader</b>(shader<font color="#666666">:resource&lt;shader&gt;</font>)</tt></td><td class="a">changes the current shader from a value received from gl_get_shader</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_get_shader</b>(shader<font color="#666666">:string</font>) -> <font color="#666666">resource&lt;shader&gt;</font></tt></td><td class="a">gets a shader by name, for use with gl_set_shader</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_set_uniform</b>(name<font color="#666666">:string</font>, value<font color="#666666">:vec_f</font>) -> <font color="#666666">int</font></tt></td><td class="a">set a uniform on the current shader. size of float vector must match size of uniform in the shader. returns false on error.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_set_uniform</b>(name<font color="#666666">:string</font>, value<font color="#666666">:float</font>) -> <font color="#666666">int</font></tt></td><td class="a">set a uniform on the current shader. uniform in the shader must be a single float. returns false on error.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_set_uniform</b>(name<font color="#666666">:string</font>, value<font color="#666666">:vec_i</font>) -> <font color="#666666">int</font></tt></td><td class="a">set a uniform on the current shader. size of int vector must match size of uniform in the shader. returns false on error.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_set_uniform</b>(name<font color="#666666">:string</font>, value<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">set a uniform on the current shader. uniform in the shader must be a single int. returns false on error.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_set_uniform_array</b>(name<font color="#666666">:string</font>, value<font color="#666666">:[float4]</font>) -> <font color="#666666">int</font></tt></td><td class="a">set a uniform on the current shader. uniform in the shader must be an array of vec4. returns false on error.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_set_uniform_matrix</b>(name<font color="#666666">:string</font>, value<font color="#666666">:[float]</font>, morerows<font color="#666666">:bool</font> = false) -> <font color="#666666">int</font></tt></td><td class="a">set a uniform on the current shader. pass a vector of 4/6/9/12/16 floats to set a mat2/mat3x2/mat3/mat4x3/mat4 respectively. pass true for morerows to get mat2x3/mat3x4. returns false on error.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_update_buffer_object</b>(value<font color="#666666">:string</font>, ssbo<font color="#666666">:int</font>, offset<font color="#666666">:int</font>, existing<font color="#666666">:resource&lt;bufferobject&gt;</font>, dyn<font color="#666666">:bool</font>) -> <font color="#666666">resource&lt;bufferobject&gt;</font></tt></td><td class="a">creates a uniform buffer object ssbo indicates if you want a shader storage block instead. returns buffer id or 0 on error.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_bind_buffer_object</b>(name<font color="#666666">:string</font>, bo<font color="#666666">:resource&lt;bufferobject&gt;</font>) -> <font color="#666666">int</font></tt></td><td class="a">attaches an existing bo to the current shader at the given uniform block name. uniforms in the shader can be any type, as long as it matches the data layout in the string buffer. returns false for error.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_copy_buffer_object</b>(source<font color="#666666">:resource&lt;bufferobject&gt;</font>, destination<font color="#666666">:resource&lt;bufferobject&gt;</font>, srcoffset<font color="#666666">:int</font>, dstoffset<font color="#666666">:int</font>, length<font color="#666666">:int</font>)</tt></td><td class="a">copies the source buffer object into the destination buffer object</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_bind_mesh_to_compute</b>(mesh<font color="#666666">:resource&lt;mesh&gt;</font>, name<font color="#666666">:string</font>)</tt></td><td class="a">Bind the vertex data of a mesh to a SSBO binding of a compute shader. Pass a nil mesh to unbind.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_dispatch_compute</b>(groups<font color="#666666">:int3</font>)</tt></td><td class="a">dispatches the currently set compute shader in groups of sizes of the specified x/y/z values.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_dump_shader</b>(filename<font color="#666666">:string</font>, stripnonascii<font color="#666666">:bool</font>) -> <font color="#666666">int</font></tt></td><td class="a">Dumps the compiled (binary) version of the current shader to a file. Contents are driver dependent. On Nvidia hardware it contains the assembly version of the shader as text, pass true for stripnonascii if you're only interested in that part.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_blend</b>(on<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">changes the blending mode (use blending constants from color.lobster), returns old mode</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_load_texture</b>(name<font color="#666666">:string</font>, textureformat<font color="#666666">:int</font> = 0) -> <font color="#666666">resource&lt;texture&gt;?</font></tt></td><td class="a">returns texture if succesfully loaded from file name, otherwise nil. see texture.lobster for texture format. If textureformat includes cubemap, will load 6 images with "_ft" etc inserted before the "." in the filename. Uses stb_image internally (see http://nothings.org/), loads JPEG Baseline, subsets of PNG, TGA, BMP, PSD, GIF, HDR, PIC.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_set_primitive_texture</b>(i<font color="#666666">:int</font>, tex<font color="#666666">:resource&lt;texture&gt;</font>)</tt></td><td class="a">sets texture unit i to texture (for use with rect/circle/polygon/line)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_set_mesh_texture</b>(mesh<font color="#666666">:resource&lt;mesh&gt;</font>, part<font color="#666666">:int</font>, i<font color="#666666">:int</font>, texture<font color="#666666">:resource&lt;texture&gt;</font>)</tt></td><td class="a">sets texture unit i to texture for a mesh and part (0 if not a multi-part mesh)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_set_image_texture</b>(i<font color="#666666">:int</font>, tex<font color="#666666">:resource&lt;texture&gt;</font>, level<font color="#666666">:int</font>, accessflags<font color="#666666">:int</font> = 0)</tt></td><td class="a">sets image unit i to texture (for use with compute). optionally specify writeonly/readwrite flags.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_create_texture</b>(matrix<font color="#666666">:[[float4]]</font>, textureformat<font color="#666666">:int</font> = 0) -> <font color="#666666">resource&lt;texture&gt;</font></tt></td><td class="a">creates a texture from a 2d array of color vectors. see texture.lobster for texture format</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_create_blank_texture</b>(size<font color="#666666">:int3</font>, textureformat<font color="#666666">:int</font> = 0) -> <font color="#666666">resource&lt;texture&gt;</font></tt></td><td class="a">creates a blank texture (for use as frame buffer or with compute shaders). see texture.lobster for texture format</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_create_colored_texture</b>(size<font color="#666666">:int3</font>, color<font color="#666666">:float4</font>, textureformat<font color="#666666">:int</font> = 0) -> <font color="#666666">resource&lt;texture&gt;</font></tt></td><td class="a">creates a colored texture (for use as frame buffer or with compute shaders). see texture.lobster for texture format</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_texture_size</b>(tex<font color="#666666">:resource&lt;texture&gt;</font>) -> <font color="#666666">int2</font></tt></td><td class="a">returns the size of a texture</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_read_texture</b>(tex<font color="#666666">:resource&lt;texture&gt;</font>) -> <font color="#666666">string?</font></tt></td><td class="a">read back RGBA texture data into a string or nil on failure</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_generate_texture_mipmap</b>(tex<font color="#666666">:resource&lt;texture&gt;</font> = nil)</tt></td><td class="a">generate mipmaps for the specified texture</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_set_texture_flags</b>(tex<font color="#666666">:resource&lt;texture&gt;</font>, tf<font color="#666666">:int</font>)</tt></td><td class="a">change texture filter/wrap/clamp flags on an existing texture</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_switch_to_framebuffer</b>(tex<font color="#666666">:resource&lt;texture&gt;</font> = nil, hasdepth<font color="#666666">:int</font> = 0, multisampleformat<font color="#666666">:int</font> = 0, resolvetex<font color="#666666">:resource&lt;texture&gt;</font> = nil, depthtex<font color="#666666">:resource&lt;texture&gt;</font> = nil) -> <font color="#666666">int</font></tt></td><td class="a">switches to a new framebuffer, that renders into the given texture. also allocates a depth buffer for it if depth is true. pass the multisample flags that was used for this texture. pass a resolve texture if the base texture is multisample. pass your own depth texture if desired. pass a nil texture to switch back to the original framebuffer. performance note: do not recreate texture passed in unless necessary.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_framebuffer_size</b>() -> <font color="#666666">int2</font></tt></td><td class="a">a vector representing the size (in pixels) of the framebuffer, according to the last call to gl_switch_to_framebuffer, or same as gl_window_size otherwise</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_light</b>(pos<font color="#666666">:float3</font>, params<font color="#666666">:float2</font>)</tt></td><td class="a">sets up a light at the given position for this frame. make sure to call this after your camera transforms but before any object transforms (i.e. defined in "worldspace"). params contains specular exponent in x (try 32/64/128 for different material looks) and the specular scale in y (try 1 for full intensity)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_render_tiles</b>(positions<font color="#666666">:[float2]</font>, tilecoords<font color="#666666">:[int2]</font>, mapsize<font color="#666666">:int2</font>)</tt></td><td class="a">Renders a list of tiles from a tilemap. Each tile rendered is 1x1 in size. Positions may be anywhere. tilecoords are indices into the map (0..mapsize-1), mapsize is the amount of tiles in the texture. Tiles may overlap, they are drawn in order. Before calling this, make sure to have the texture set and a textured shader</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_debug_grid</b>(num<font color="#666666">:int3</font>, dist<font color="#666666">:float3</font>, thickness<font color="#666666">:float</font>)</tt></td><td class="a">renders a grid in space for debugging purposes. num is the number of lines in all 3 directions, and dist their spacing. thickness of the lines in the same units</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_screenshot</b>(filename<font color="#666666">:string</font>) -> <font color="#666666">int</font></tt></td><td class="a">saves a screenshot in .png format, returns true if succesful</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_dropped_file</b>() -> <font color="#666666">string</font></tt></td><td class="a">if a file was dropped on the window this frame, the filename, otherwise empty</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_create_time_query</b>() -> <font color="#666666">resource&lt;timequery&gt;</font></tt></td><td class="a">creates a time query object used for profiling GPU events</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_start_time_query</b>(tq<font color="#666666">:resource&lt;timequery&gt;</font> = nil)</tt></td><td class="a">starts the time query</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_stop_time_query</b>(tq<font color="#666666">:resource&lt;timequery&gt;</font> = nil) -> <font color="#666666">float</font></tt></td><td class="a">stops the time query and returns the result</td></tr>
</table>
<h3>font</h3>
<table class="a" border=1 cellspacing=0 cellpadding=4>
<tr class="a" valign=top><td class="a"><tt><b>gl_set_font_name</b>(filename<font color="#666666">:string</font>) -> <font color="#666666">int</font></tt></td><td class="a">sets a freetype/OTF/TTF font as current (and loads it from disk the first time). returns true if success.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_set_font_size</b>(size<font color="#666666">:int</font>, outlinesize<font color="#666666">:float</font> = 0.000000) -> <font color="#666666">int</font></tt></td><td class="a">sets the font for rendering into this fontsize (in pixels). caches into a texture first time this size is used, flushes from cache if this size is not used an entire frame. font rendering will look best if using 1:1 pixels (careful with gl_scale/gl_translate). an optional outlinesize will give the font a black outline. make sure to call this every frame. returns true if success</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_set_max_font_size</b>(size<font color="#666666">:int</font>)</tt></td><td class="a">sets the max font size to render to bitmaps. any sizes specified over that by setfontsize will still work but cause scaled rendering. default 256</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_get_font_size</b>() -> <font color="#666666">int</font></tt></td><td class="a">the current font size</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_get_outline_size</b>() -> <font color="#666666">float</font></tt></td><td class="a">the current font size</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_text</b>(text<font color="#666666">:string</font>) -> <font color="#666666">string</font></tt></td><td class="a">renders a text with the current font (at the current coordinate origin)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_text_size</b>(text<font color="#666666">:string</font>) -> <font color="#666666">int2</font></tt></td><td class="a">the x/y size in pixels the given text would need</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_get_glyph_name</b>(i<font color="#666666">:int</font>) -> <font color="#666666">string</font></tt></td><td class="a">the name of a glyph index, or empty string if the font doesn't have names</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>gl_get_char_code</b>(name<font color="#666666">:string</font>) -> <font color="#666666">int</font></tt></td><td class="a">the char code of a glyph by specifying its name, or 0 if it can not be found (or if the font doesn't have names)</td></tr>
</table>
<h3>sound</h3>
<table class="a" border=1 cellspacing=0 cellpadding=4>
<tr class="a" valign=top><td class="a"><tt><b>play_wav</b>(filename<font color="#666666">:string</font>, loops<font color="#666666">:int</font> = 0, prio<font color="#666666">:int</font> = 0) -> <font color="#666666">int</font></tt></td><td class="a">plays a sound defined by a wav file (RAW or MS-ADPCM, any bitrate other than 22050hz 16bit will automatically be converted on first load). the default volume is the max volume (1.0) loops is the number of repeats to play (-1 repeats endlessly, omit for no repeats). prio is the priority of the sound which determines whether it can be deleted or not in case of too many play function calls (defaults to 0) returns the assigned channel number (1..8) or 0 on error</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>load_wav</b>(filename<font color="#666666">:string</font>) -> <font color="#666666">int</font></tt></td><td class="a">loads a sound the same way play_sound does, but ahead of playback, to avoid any delays later. returns false on error</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>play_sfxr</b>(filename<font color="#666666">:string</font>, loops<font color="#666666">:int</font> = 0, prio<font color="#666666">:int</font> = 0) -> <font color="#666666">int</font></tt></td><td class="a">plays a synth sound defined by a .sfs file (use http://www.drpetter.se/project_sfxr.html to generate these). the default volume is the max volume (1.0) loops is the number of repeats to play (-1 repeats endlessly, omit for no repeats). prio is the priority of the sound which determines whether it can be deleted or not in case of too many play function calls (defaults to 0) returns the assigned channel number (1..8) or 0 on error</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>load_sfxr</b>(filename<font color="#666666">:string</font>) -> <font color="#666666">int</font></tt></td><td class="a">loads a sound the same way play_sfxr does, but ahead of playback, to avoid any delays later. returns false on error</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>play_ogg</b>(filename<font color="#666666">:string</font>, loops<font color="#666666">:int</font> = 0, prio<font color="#666666">:int</font> = 0) -> <font color="#666666">int</font></tt></td><td class="a">plays an ogg file. the default volume is the max volume (1.0) loops is the number of repeats to play (-1 repeats endlessly, omit for no repeats). prio is the priority of the sound which determines whether it can be deleted or not in case of too many play function calls (defaults to 0) returns the assigned channel number (1..8) or 0 on error</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>load_ogg</b>(filename<font color="#666666">:string</font>) -> <font color="#666666">int</font></tt></td><td class="a">loads a sound the same way play_ogg does, but ahead of playback, to avoid any delays later. returns false on error</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>sound_status</b>(channel<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">provides the status of the specified sound channel. returns -1 on error or if the channel does not exist, 0 if the channel is free, 1 if it is playing, and 2 if the channel is active but paused.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>sound_halt</b>(channel<font color="#666666">:int</font>)</tt></td><td class="a">terminates a specific sound channel.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>sound_pause</b>(channel<font color="#666666">:int</font>)</tt></td><td class="a">pauses the specified sound channel.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>sound_resume</b>(channel<font color="#666666">:int</font>)</tt></td><td class="a">resumes a sound that was paused.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>sound_volume</b>(channel<font color="#666666">:int</font>, volume<font color="#666666">:float</font>)</tt></td><td class="a">sets the channel volume in the range 0..1.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>sound_position</b>(channel<font color="#666666">:int</font>, vecfromlistener<font color="#666666">:float3</font>, listenerfwd<font color="#666666">:float3</font>, attnscale<font color="#666666">:float</font>)</tt></td><td class="a">sets the channel volume and panning according to sound in a game world relative to the listener.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>text_to_speech</b>(text<font color="#666666">:string</font>)</tt></td><td class="a">Queues up text for async text to speech output. Currently on: win32</td></tr>
</table>
<h3>physics</h3>
<table class="a" border=1 cellspacing=0 cellpadding=4>
<tr class="a" valign=top><td class="a"><tt><b>ph_initialize</b>(gravityvector<font color="#666666">:float2</font>)</tt></td><td class="a">initializes or resets the physical world, gravity typically [0, -10].</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>ph_create_box</b>(position<font color="#666666">:float2</font>, size<font color="#666666">:float2</font>, offset<font color="#666666">:float2</font> = nil, rotation<font color="#666666">:float</font> = 0.000000, attachto<font color="#666666">:resource&lt;fixture&gt;</font> = nil) -> <font color="#666666">resource&lt;fixture&gt;</font></tt></td><td class="a">creates a physical box shape in the world at position, with size the half-extends around the center, offset from the center if needed, at a particular rotation (in degrees). attachto is a previous physical object to attach this one to, to become a combined physical body.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>ph_create_circle</b>(position<font color="#666666">:float2</font>, radius<font color="#666666">:float</font>, offset<font color="#666666">:float2</font> = nil, attachto<font color="#666666">:resource&lt;fixture&gt;</font> = nil) -> <font color="#666666">resource&lt;fixture&gt;</font></tt></td><td class="a">creates a physical circle shape in the world at position, with the given radius, offset from the center if needed. attachto is a previous physical object to attach this one to, to become a combined physical body.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>ph_create_polygon</b>(position<font color="#666666">:float2</font>, vertices<font color="#666666">:[float2]</font>, attachto<font color="#666666">:resource&lt;fixture&gt;</font> = nil) -> <font color="#666666">resource&lt;fixture&gt;</font></tt></td><td class="a">creates a polygon circle shape in the world at position, with the given list of vertices. attachto is a previous physical object to attach this one to, to become a combined physical body.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>ph_dynamic</b>(shape<font color="#666666">:resource&lt;fixture&gt;</font>, on<font color="#666666">:bool</font>)</tt></td><td class="a">makes a shape dynamic (on = true) or not.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>ph_set_linear_velocity</b>(id<font color="#666666">:resource&lt;fixture&gt;</font>, velocity<font color="#666666">:float2</font>)</tt></td><td class="a">sets the linear velocity of a shape's center of mass.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>ph_apply_linear_impulse_to_center</b>(id<font color="#666666">:resource&lt;fixture&gt;</font>, impulse<font color="#666666">:float2</font>)</tt></td><td class="a">applies a linear impulse to a shape at its center of mass.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>ph_set_color</b>(id<font color="#666666">:resource&lt;fixture&gt;</font>, color<font color="#666666">:float4</font>)</tt></td><td class="a">sets a shape (or nil for particles) to be rendered with a particular color.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>ph_set_shader</b>(id<font color="#666666">:resource&lt;fixture&gt;</font>, shadername<font color="#666666">:string</font>)</tt></td><td class="a">sets a shape (or nil for particles) to be rendered with a particular shader.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>ph_set_texture</b>(id<font color="#666666">:resource&lt;fixture&gt;</font>, tex<font color="#666666">:resource&lt;texture&gt;</font>, texunit<font color="#666666">:int</font> = 0)</tt></td><td class="a">sets a shape (or nil for particles) to be rendered with a particular texture (assigned to a texture unit, default 0).</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>ph_get_position</b>(id<font color="#666666">:resource&lt;fixture&gt;</font>) -> <font color="#666666">float2</font></tt></td><td class="a">gets a shape's position.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>ph_get_mass</b>(id<font color="#666666">:resource&lt;fixture&gt;</font>) -> <font color="#666666">float</font></tt></td><td class="a">gets a shape's mass.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>ph_create_particle</b>(position<font color="#666666">:float2</font>, velocity<font color="#666666">:float2</font>, color<font color="#666666">:float4</font>, flags<font color="#666666">:int</font> = 0) -> <font color="#666666">int</font></tt></td><td class="a">creates an individual particle. For flags, see include/physics.lobster</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>ph_create_particle_circle</b>(position<font color="#666666">:float2</font>, radius<font color="#666666">:float</font>, color<font color="#666666">:float4</font>, flags<font color="#666666">:int</font> = 0)</tt></td><td class="a">creates a circle filled with particles. For flags, see include/physics.lobster</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>ph_initialize_particles</b>(radius<font color="#666666">:float</font>)</tt></td><td class="a">initializes the particle system with a given particle radius.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>ph_step</b>(seconds<font color="#666666">:float</font>, viter<font color="#666666">:int</font>, piter<font color="#666666">:int</font>)</tt></td><td class="a">simulates the physical world for the given period (try: gl_delta_time()). You can specify the amount of velocity/position iterations per step, more means more accurate but also more expensive computationally (try 8 and 3).</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>ph_particle_contacts</b>(id<font color="#666666">:resource&lt;fixture&gt;</font>) -> <font color="#666666">[int]</font></tt></td><td class="a">gets the particle indices that are currently contacting a giving physics object. Call after step(). Indices may be invalid after next step().</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>ph_raycast</b>(p1<font color="#666666">:float2</font>, p2<font color="#666666">:float2</font>, n<font color="#666666">:int</font>) -> <font color="#666666">[int]</font></tt></td><td class="a">returns a vector of the first n particle ids that intersect a ray from p1 to p2, not including particles that overlap p1.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>ph_delete_particle</b>(i<font color="#666666">:int</font>)</tt></td><td class="a">deletes given particle. Deleting particles causes indices to be invalidated at next step().</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>ph_getparticle_position</b>(i<font color="#666666">:int</font>) -> <font color="#666666">float2</font></tt></td><td class="a">gets a particle's position.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>ph_render</b>()</tt></td><td class="a">renders all rigid body objects.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>ph_render_particles</b>(scale<font color="#666666">:float</font>)</tt></td><td class="a">render all particles, with the given scale.</td></tr>
</table>
<h3>noise</h3>
<table class="a" border=1 cellspacing=0 cellpadding=4>
<tr class="a" valign=top><td class="a"><tt><b>simplex</b>(pos<font color="#666666">:vec_f</font>, octaves<font color="#666666">:int</font>, scale<font color="#666666">:float</font>, persistence<font color="#666666">:float</font>) -> <font color="#666666">float</font></tt></td><td class="a">returns a simplex noise value [-1..1] given a 2D/3D or 4D location, the number of octaves (try 8), a scale (try 1), and persistence from one octave to the next (try 0.5)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>simplex_raw</b>(pos<font color="#666666">:vec_f</font>) -> <font color="#666666">float</font></tt></td><td class="a">returns a simplex noise value [-1..1] given a 2D/3D or 4D location</td></tr>
</table>
<h3>meshgen</h3>
<table class="a" border=1 cellspacing=0 cellpadding=4>
<tr class="a" valign=top><td class="a"><tt><b>mg_sphere</b>(radius<font color="#666666">:float</font>)</tt></td><td class="a">a sphere</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>mg_cube</b>(extents<font color="#666666">:float3</font>)</tt></td><td class="a">a cube (extents are size from center)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>mg_cylinder</b>(radius<font color="#666666">:float</font>, height<font color="#666666">:float</font>)</tt></td><td class="a">a unit cylinder (height is from center)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>mg_tapered_cylinder</b>(bot<font color="#666666">:float</font>, top<font color="#666666">:float</font>, height<font color="#666666">:float</font>)</tt></td><td class="a">a cyclinder where you specify the top and bottom radius (height is from center)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>mg_superquadric</b>(exponents<font color="#666666">:float3</font>, scale<font color="#666666">:float3</font>)</tt></td><td class="a">a super quadric. specify an exponent of 2 for spherical, higher values for rounded squares</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>mg_superquadric_non_uniform</b>(posexponents<font color="#666666">:float3</font>, negexponents<font color="#666666">:float3</font>, posscale<font color="#666666">:float3</font>, negscale<font color="#666666">:float3</font>)</tt></td><td class="a">a superquadric that allows you to specify exponents and sizes in all 6 directions independently for maximum modelling possibilities</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>mg_supertoroid</b>(R<font color="#666666">:float</font>, exponents<font color="#666666">:float3</font>)</tt></td><td class="a">a super toroid. R is the distance from the origin to the center of the ring.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>mg_landscape</b>(zscale<font color="#666666">:float</font>, xyscale<font color="#666666">:float</font>)</tt></td><td class="a">a simplex landscape of unit size</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>mg_set_polygon_reduction</b>(polyreductionpasses<font color="#666666">:int</font>, epsilon<font color="#666666">:float</font>, maxtricornerdot<font color="#666666">:float</font>)</tt></td><td class="a">controls the polygon reduction algorithm. set polyreductionpasses to 0 for off, 100 for max compression, or low values for generation speed or to keep the mesh uniform. epsilon determines how flat adjacent triangles must be to be reduced, use 0.98 as a good tradeoff, lower to get more compression. maxtricornerdot avoid very thin triangles, use 0.95 as a good tradeoff, up to 0.99 to get more compression</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>mg_set_color_noise</b>(noiseintensity<font color="#666666">:float</font>, noisestretch<font color="#666666">:float</font>)</tt></td><td class="a">applies simplex noise to the colors of the model. try 0.3 for intensity. stretch scales the pattern over the model</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>mg_set_vertex_randomize</b>(factor<font color="#666666">:float</font>)</tt></td><td class="a">randomizes all verts produced to give a more organic look and to hide the inherent messy polygons produced by the algorithm. try 0.15. note that any setting other than 0 will likely counteract the polygon reduction algorithm</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>mg_set_point_mode</b>(on<font color="#666666">:bool</font>)</tt></td><td class="a">generates a point mesh instead of polygons</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>mg_polygonize</b>(subdiv<font color="#666666">:int</font>) -> <font color="#666666">resource&lt;mesh&gt;</font></tt></td><td class="a">returns a generated mesh from past mg_ commands. subdiv determines detail and number of polygons (relative to the largest dimension of the model), try 30.. 300 depending on the subject. values much higher than that will likely make you run out of memory (or take very long).</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>mg_convert_to_cubes</b>(subdiv<font color="#666666">:int</font>, zoffset<font color="#666666">:int</font>) -> <font color="#666666">resource&lt;voxels&gt;</font></tt></td><td class="a">returns a cubegen block (see cg_ functions) from past mg_ commands. subdiv determines detail and number of cubes (relative to the largest dimension of the model).</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>mg_translate</b>(vec<font color="#666666">:float3</font>)</tt></td><td class="a">translates the current coordinate system along a vector</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>mg_scale</b>(f<font color="#666666">:float</font>)</tt></td><td class="a">scales the current coordinate system by the given factor</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>mg_scale_vec</b>(vec<font color="#666666">:float3</font>)</tt></td><td class="a">non-unimformly scales the current coordinate system using individual factors per axis</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>mg_rotate</b>(axis<font color="#666666">:float3</font>, angle<font color="#666666">:float</font>)</tt></td><td class="a">rotates using axis/angle</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>mg_color</b>(color<font color="#666666">:float4</font>)</tt></td><td class="a">sets the color, where an alpha of 1 means to add shapes to the scene (union), and 0 substracts them (carves)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>mg_smooth</b>(smooth<font color="#666666">:float</font>)</tt></td><td class="a">sets the smoothness in terms of the range of distance from the shape smoothing happens, defaults to 1.0</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>mg_push_transform</b>()</tt></td><td class="a">save the current state of the transform</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>mg_pop_transform</b>()</tt></td><td class="a">restore a previous state of the transform</td></tr>
</table>
<h3>cubegen</h3>
<table class="a" border=1 cellspacing=0 cellpadding=4>
<tr class="a" valign=top><td class="a"><tt><b>cg_init</b>(size<font color="#666666">:int3</font>) -> <font color="#666666">resource&lt;voxels&gt;</font></tt></td><td class="a">initializes a new, empty 3D cube block. 1 byte per cell, careful with big sizes :) returns the block</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>cg_size</b>(block<font color="#666666">:resource&lt;voxels&gt;</font>) -> <font color="#666666">int3</font></tt></td><td class="a">returns the current block size</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>cg_name</b>(block<font color="#666666">:resource&lt;voxels&gt;</font>) -> <font color="#666666">string</font></tt></td><td class="a">returns the current block name</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>cg_offset</b>(block<font color="#666666">:resource&lt;voxels&gt;</font>) -> <font color="#666666">int3</font></tt></td><td class="a">returns the current block offset</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>cg_set</b>(block<font color="#666666">:resource&lt;voxels&gt;</font>, pos<font color="#666666">:int3</font>, size<font color="#666666">:int3</font>, paletteindex<font color="#666666">:int</font>)</tt></td><td class="a">sets a range of cubes to palette index. index 0 is considered empty space.Coordinates automatically clipped to the size of the grid</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>cg_get</b>(block<font color="#666666">:resource&lt;voxels&gt;</font>, pos<font color="#666666">:int3</font>) -> <font color="#666666">int</font></tt></td><td class="a">sets a range of cubes to palette index. index 0 is considered empty space.Coordinates automatically clipped to the size of the grid</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>cg_copy</b>(block<font color="#666666">:resource&lt;voxels&gt;</font>, pos<font color="#666666">:int3</font>, size<font color="#666666">:int3</font>, dest<font color="#666666">:int3</font>, flip<font color="#666666">:int3</font>)</tt></td><td class="a">copy a range of cubes from pos to dest. flip can be 1 (regular copy), or -1 (mirror)for each component, indicating the step from dest. Coordinates automatically clipped to the size of the grid</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>cg_clone</b>(block<font color="#666666">:resource&lt;voxels&gt;</font>, pos<font color="#666666">:int3</font>, size<font color="#666666">:int3</font>) -> <font color="#666666">resource&lt;voxels&gt;</font></tt></td><td class="a">clone a range of cubes from pos to a new block. Coordinates automatically clipped to the size of the grid</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>cg_color_to_palette</b>(block<font color="#666666">:resource&lt;voxels&gt;</font>, color<font color="#666666">:float4</font>) -> <font color="#666666">int</font></tt></td><td class="a">converts a color to a palette index. alpha &lt; 0.5 is considered empty space. note: this is fast for the default palette, slow otherwise.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>cg_palette_to_color</b>(block<font color="#666666">:resource&lt;voxels&gt;</font>, paletteindex<font color="#666666">:int</font>) -> <font color="#666666">float4</font></tt></td><td class="a">converts a palette index to a color. empty space (index 0) will have 0 alpha</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>cg_copy_palette</b>(fromworld<font color="#666666">:resource&lt;voxels&gt;</font>, toworld<font color="#666666">:resource&lt;voxels&gt;</font>)</tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>cg_sample_down</b>(scale<font color="#666666">:int</font>, world<font color="#666666">:resource&lt;voxels&gt;</font>)</tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>cg_scale_up</b>(scale<font color="#666666">:int</font>, world<font color="#666666">:resource&lt;voxels&gt;</font>) -> <font color="#666666">resource&lt;voxels&gt;</font></tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>cg_stretch</b>(newsize<font color="#666666">:int3</font>, world<font color="#666666">:resource&lt;voxels&gt;</font>) -> <font color="#666666">resource&lt;voxels&gt;</font></tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>cg_create_mesh</b>(block<font color="#666666">:resource&lt;voxels&gt;</font>) -> <font color="#666666">resource&lt;mesh&gt;</font></tt></td><td class="a">converts block to a mesh</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>cg_create_3d_texture</b>(block<font color="#666666">:resource&lt;voxels&gt;</font>, textureformat<font color="#666666">:int</font>, monochrome<font color="#666666">:int</font> = 0) -> <font color="#666666">resource&lt;texture&gt;</font></tt></td><td class="a">returns the new texture, for format, pass flags you want in addition to 3d|single_channel|has_mips</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>cg_load_vox</b>(name<font color="#666666">:string</font>, material_palette<font color="#666666">:int</font> = 0) -> <font color="#666666">[resource&lt;voxels&gt;]</font>, <font color="#666666">string?</font></tt></td><td class="a">loads a .vox file (supports both MagicaVoxel or VoxLap formats). if material_palette is true the alpha channel will contain material flags. returns vector of blocks or empty if file failed to load, and error string if any</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>cg_save_vox</b>(block<font color="#666666">:resource&lt;voxels&gt;</font>, name<font color="#666666">:string</font>) -> <font color="#666666">int</font></tt></td><td class="a">saves a file in the .vox format (MagicaVoxel). returns false if file failed to save. this format can only save blocks &lt; 256^3, will fail if bigger</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>cg_chunks_skipped</b>(block<font color="#666666">:resource&lt;voxels&gt;</font>) -> <font color="#666666">int</font></tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>cg_get_buf</b>(block<font color="#666666">:resource&lt;voxels&gt;</font>) -> <font color="#666666">string</font></tt></td><td class="a">returns the data as a string of all palette indices, in z-major order</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>cg_average_surface_color</b>(world<font color="#666666">:resource&lt;voxels&gt;</font>) -> <font color="#666666">float3</font>, <font color="#666666">int</font>, <font color="#666666">int</font></tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>cg_average_face_colors</b>(world<font color="#666666">:resource&lt;voxels&gt;</font>) -> <font color="#666666">[float]</font></tt></td><td class="a">returns a vector of 7 elements with 4 floats per face: color and alpha.last element contains the total average color and alpha</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>cg_num_solid</b>(world<font color="#666666">:resource&lt;voxels&gt;</font>) -> <font color="#666666">int</font></tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>cg_rotate</b>(block<font color="#666666">:resource&lt;voxels&gt;</font>, n<font color="#666666">:int</font>) -> <font color="#666666">resource&lt;voxels&gt;</font></tt></td><td class="a">returns a new block rotated by n 90 degree steps from the input</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>cg_simplex</b>(block<font color="#666666">:resource&lt;voxels&gt;</font>, pos<font color="#666666">:int3</font>, size<font color="#666666">:int3</font>, spos<font color="#666666">:float3</font>, ssize<font color="#666666">:float3</font>, octaves<font color="#666666">:int</font>, scale<font color="#666666">:float</font>, persistence<font color="#666666">:float</font>, solidcol<font color="#666666">:int</font>, zscale<font color="#666666">:float</font>, zbias<font color="#666666">:float</font>)</tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>cg_bounding_box</b>(world<font color="#666666">:resource&lt;voxels&gt;</font>, minsolids<font color="#666666">:float</font>) -> <font color="#666666">int3</font>, <font color="#666666">int3</font></tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>cg_randomize</b>(world<font color="#666666">:resource&lt;voxels&gt;</font>, rnd_range<font color="#666666">:int</font>, cutoff<font color="#666666">:int</font>, paletteindex<font color="#666666">:int</font>, filter<font color="#666666">:int</font>)</tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>cg_erode</b>(world<font color="#666666">:resource&lt;voxels&gt;</font>, minsolid<font color="#666666">:int</font>, maxsolid<font color="#666666">:int</font>) -> <font color="#666666">resource&lt;voxels&gt;</font></tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>cg_normal_indices</b>(block<font color="#666666">:resource&lt;voxels&gt;</font>, radius<font color="#666666">:int</font>) -> <font color="#666666">resource&lt;voxels&gt;</font></tt></td><td class="a">creates a new block with normal indices based on voxel surface shape.the indices refer to the associated pallette.empty voxels will have a 0 length normal.2 is a good radius that balances speed/quality, use 1 for speed, 3 for max quality</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>cg_load_image</b>(name<font color="#666666">:string</font>, depth<font color="#666666">:int</font>, edge<font color="#666666">:int</font>, numtiles<font color="#666666">:int2</font>) -> <font color="#666666">[resource&lt;voxels&gt;]</font></tt></td><td class="a">loads an image file (same formats as gl_load_texture) and turns it into blocks. returns blocks or [] if file failed to load</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>cg_palette_storage_index</b>(block<font color="#666666">:resource&lt;voxels&gt;</font>) -> <font color="#666666">int</font></tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>cg_get_palette_storage_len</b>() -> <font color="#666666">int</font></tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>cg_get_palette_storage_buf</b>() -> <font color="#666666">string</font></tt></td><td class="a"></td></tr>
</table>
<h3>vr</h3>
<table class="a" border=1 cellspacing=0 cellpadding=4>
<tr class="a" valign=top><td class="a"><tt><b>vr_init</b>() -> <font color="#666666">int</font></tt></td><td class="a">initializes VR mode. returns true if a hmd was found and initialized</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>vr_start_eye</b>(isright<font color="#666666">:int</font>, znear<font color="#666666">:float</font>, zfar<font color="#666666">:float</font>)</tt></td><td class="a">starts rendering for an eye. call for each eye, followed by drawing the world as normal. replaces gl_perspective</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>vr_start</b>()</tt></td><td class="a">starts VR by updating hmd &amp; controller poses</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>vr_finish</b>()</tt></td><td class="a">finishes vr rendering by compositing (and distorting) both eye renders to the screen</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>vr_set_eye_texture</b>(unit<font color="#666666">:int</font>, isright<font color="#666666">:int</font>)</tt></td><td class="a">sets the texture for an eye (like gl_set_primitive_texture). call after vr_finish. can be used to render the non-VR display</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>vr_num_motion_controllers</b>() -> <font color="#666666">int</font></tt></td><td class="a">returns the number of motion controllers in the system</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>vr_motioncontrollerstracking</b>(n<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">returns if motion controller n is tracking</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>vr_motion_controller</b>(n<font color="#666666">:int</font>)</tt></td><td class="a">sets up the transform ready to render controller n. if there is no controller n (or it is currently not tracking) the identity transform is used</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>vr_create_motion_controller_mesh</b>(n<font color="#666666">:int</font>) -> <font color="#666666">resource&lt;mesh&gt;?</font></tt></td><td class="a">returns the mesh for motion controller n, or nil if not available</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>vr_motion_controller_button</b>(n<font color="#666666">:int</font>, button<font color="#666666">:string</font>) -> <font color="#666666">int</font></tt></td><td class="a">returns the button state for motion controller n. isdown: &gt;= 1, wentdown: == 1, wentup: == 0, isup: &lt;= 0. buttons are: system, menu, grip, trigger, touchpad</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>vr_motion_controller_vec</b>(n<font color="#666666">:int</font>, i<font color="#666666">:int</font>) -> <font color="#666666">float3</font></tt></td><td class="a">returns one of the vectors for motion controller n. 0 = left, 1 = up, 2 = fwd, 4 = pos. These are in Y up space.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>vr_hmd_vec</b>(i<font color="#666666">:int</font>) -> <font color="#666666">float3</font></tt></td><td class="a">returns one of the vectors for hmd pose. 0 = left, 1 = up, 2 = fwd, 4 = pos. These are in Y up space.</td></tr>
</table>
<h3>steam</h3>
<table class="a" border=1 cellspacing=0 cellpadding=4>
<tr class="a" valign=top><td class="a"><tt><b>steam_init</b>(appid<font color="#666666">:int</font>, allowscreenshots<font color="#666666">:bool</font>, initrelay<font color="#666666">:bool</font>) -> <font color="#666666">int</font></tt></td><td class="a">initializes SteamWorks. returns 1 if succesful, 0 on failure. Specify a non-0 appid if you want to restart from steam if this wasn't started from steam (the return value in this case will be -1 to indicate you should terminate this instance). If you don't specify an appid here or in steam_appid.txt, init will likely fail. The other functions can still be called even if steam isn't active. allowscreenshots automatically uploads screenshots to steam (triggered by steam). initrelay initializes the relay network for p2p early, to save time when it is first used.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>steam_shutdown</b>()</tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>steam_overlay</b>() -> <font color="#666666">int</font></tt></td><td class="a">returns true if the steam overlay is currently on (you may want to auto-pause if so)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>steam_username</b>() -> <font color="#666666">string</font></tt></td><td class="a">returns the name of the steam user, or empty string if not available.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>steam_unlock_achievement</b>(achievementname<font color="#666666">:string</font>) -> <font color="#666666">int</font></tt></td><td class="a">Unlocks an achievement and shows the achievement overlay if not already achieved before. Will also Q-up saving achievement to Steam. Returns true if succesful.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>steam_write_file</b>(file<font color="#666666">:string</font>, contents<font color="#666666">:string</font>) -> <font color="#666666">int</font></tt></td><td class="a">writes a file with the contents of a string to the steam cloud, or local storage if that fails, returns false if writing wasn't possible at all</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>steam_read_file</b>(file<font color="#666666">:string</font>) -> <font color="#666666">string?</font></tt></td><td class="a">returns the contents of a file as a string from the steam cloud if available, or otherwise from local storage, or nil if the file can't be found at all.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>steam_update</b>()</tt></td><td class="a">you must call this function in your game loop when using most steam APIs</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>steam_net_identity</b>() -> <font color="#666666">string</font></tt></td><td class="a">returns the steam identity for this user. This same ID will be used for connecting to peers, sending messages, etc.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>steam_p2p_listen</b>() -> <font color="#666666">int</font></tt></td><td class="a">open a listen socket to receive new connections</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>steam_p2p_close_listen</b>() -> <font color="#666666">int</font></tt></td><td class="a">close the listen socket and stop accepting new connections</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>steam_p2p_connect</b>(ident<font color="#666666">:string</font>) -> <font color="#666666">int</font></tt></td><td class="a">connect to a user with a given steam identity that has opened a listen socket</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>steam_p2p_get_connections</b>() -> <font color="#666666">[string]</font></tt></td><td class="a">get a list of the steam identites that are currently connected</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>steam_p2p_send_message</b>(ident<font color="#666666">:string</font>, data<font color="#666666">:string</font>) -> <font color="#666666">int</font></tt></td><td class="a">send a reliable message to a given steam identity</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>steam_p2p_broadcast_message</b>(data<font color="#666666">:string</font>) -> <font color="#666666">int</font></tt></td><td class="a">send a reliable message to all connected peers</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>steam_p2p_receive_messages</b>() -> <font color="#666666">[string]</font>, <font color="#666666">[string]</font></tt></td><td class="a">receive messages from all connected peers. The first return value is an array of messages, the second return value is an array of the steam identities that sent each message</td></tr>
</table>
<h3>imgui</h3>
<table class="a" border=1 cellspacing=0 cellpadding=4>
<tr class="a" valign=top><td class="a"><tt><b>im_init</b>(dark_style<font color="#666666">:bool</font> = false, flags<font color="#666666">:int</font> = 0, rounding<font color="#666666">:float</font> = 0.000000)</tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_add_font</b>(font_path<font color="#666666">:string</font>, size<font color="#666666">:float</font>) -> <font color="#666666">int</font></tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_frame_start</b>()</tt></td><td class="a">(use im_frame instead)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_frame_end</b>()</tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_dockspace_over_viewport</b>()</tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_window_demo</b>() -> <font color="#666666">int</font></tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_window_start</b>(title<font color="#666666">:string</font>, flags<font color="#666666">:int</font>, dock<font color="#666666">:int</font>)</tt></td><td class="a">(use im_window instead)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_window_end</b>()</tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_next_window_size</b>(size<font color="#666666">:float2</font>)</tt></td><td class="a">size in pixels</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_next_window_pos</b>(pos<font color="#666666">:float2</font>, pivot<font color="#666666">:float2</font>)</tt></td><td class="a">pos in pixels, pivot values 0..1 relative to pos</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_button</b>(label<font color="#666666">:string</font>) -> <font color="#666666">int</font></tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_selectable</b>(label<font color="#666666">:string</font>, selected<font color="#666666">:bool</font> = false) -> <font color="#666666">int</font></tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_same_line</b>()</tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_new_line</b>()</tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_separator</b>()</tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_get_layout_pos</b>() -> <font color="#666666">float2</font></tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_set_layout_pos</b>(pos<font color="#666666">:float2</font>)</tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_get_content_region_avail</b>() -> <font color="#666666">float2</font></tt></td><td class="a">returns the amount of space left in the current region from the cursor pos</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_text</b>(label<font color="#666666">:string</font>)</tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_text_styled</b>(label<font color="#666666">:string</font>, font_idx<font color="#666666">:int</font>, color<font color="#666666">:float4</font>)</tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_text_wrapped</b>(label<font color="#666666">:string</font>)</tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_tooltip</b>(label<font color="#666666">:string</font>)</tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_tooltip_multi_start</b>() -> <font color="#666666">int</font></tt></td><td class="a">(use im_tooltip_multi instead)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_tooltip_multi_end</b>()</tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_checkbox</b>(label<font color="#666666">:string</font>, bool<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_input_text</b>(label<font color="#666666">:string</font>, str<font color="#666666">:string</font>) -> <font color="#666666">string</font></tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_input_text_multi_line</b>(label<font color="#666666">:string</font>, str<font color="#666666">:string</font>, num_lines<font color="#666666">:int</font>) -> <font color="#666666">string</font></tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_input_int</b>(label<font color="#666666">:string</font>, val<font color="#666666">:int</font>, min<font color="#666666">:int</font>, max<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_input_float</b>(label<font color="#666666">:string</font>, val<font color="#666666">:float</font>) -> <font color="#666666">float</font></tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_radio</b>(labels<font color="#666666">:[string]</font>, active<font color="#666666">:int</font>, horiz<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">active to select which one is activated, -2 for last frame's selection or 0</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_combo</b>(label<font color="#666666">:string</font>, labels<font color="#666666">:[string]</font>, active<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">active to select which one is activated, -2 for last frame's selection or 0</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_listbox</b>(label<font color="#666666">:string</font>, labels<font color="#666666">:[string]</font>, active<font color="#666666">:int</font>, height<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">active to select which one is activated, -1 for no initial selection, -2 for last frame's selection or none</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_sliderint</b>(label<font color="#666666">:string</font>, i<font color="#666666">:int</font>, min<font color="#666666">:int</font>, max<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_sliderfloat</b>(label<font color="#666666">:string</font>, f<font color="#666666">:float</font>, min<font color="#666666">:float</font>, max<font color="#666666">:float</font>) -> <font color="#666666">float</font></tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_sliderint2</b>(label<font color="#666666">:string</font>, I2<font color="#666666">:int2</font>, min<font color="#666666">:int</font>, max<font color="#666666">:int</font>) -> <font color="#666666">int2</font></tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_sliderint3</b>(label<font color="#666666">:string</font>, I3<font color="#666666">:int3</font>, min<font color="#666666">:int</font>, max<font color="#666666">:int</font>) -> <font color="#666666">int3</font></tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_sliderint4</b>(label<font color="#666666">:string</font>, I4<font color="#666666">:int4</font>, min<font color="#666666">:int</font>, max<font color="#666666">:int</font>) -> <font color="#666666">int4</font></tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_sliderfloat2</b>(label<font color="#666666">:string</font>, F2<font color="#666666">:float2</font>, min<font color="#666666">:float</font>, max<font color="#666666">:float</font>) -> <font color="#666666">float2</font></tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_sliderfloat3</b>(label<font color="#666666">:string</font>, F3<font color="#666666">:float3</font>, min<font color="#666666">:float</font>, max<font color="#666666">:float</font>) -> <font color="#666666">float3</font></tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_sliderfloat4</b>(label<font color="#666666">:string</font>, F4<font color="#666666">:float4</font>, min<font color="#666666">:float</font>, max<font color="#666666">:float</font>) -> <font color="#666666">float4</font></tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_coloredit</b>(label<font color="#666666">:string</font>, color<font color="#666666">:vec_f</font>) -> <font color="#666666">any</font></tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_image</b>(tex<font color="#666666">:resource&lt;texture&gt;</font>, size<font color="#666666">:float2</font>)</tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_image_button</b>(label<font color="#666666">:string</font>, tex<font color="#666666">:resource&lt;texture&gt;</font>, size<font color="#666666">:float2</font>, bgcol<font color="#666666">:float4</font> = nil) -> <font color="#666666">int</font></tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_image_mouseclick</b>(tex<font color="#666666">:resource&lt;texture&gt;</font>, size<font color="#666666">:float2</font>) -> <font color="#666666">float2</font>, <font color="#666666">int</font></tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_treenode_start</b>(label<font color="#666666">:string</font>, flags<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">(use im_treenode instead)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_treenode_end</b>()</tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_tab_bar_start</b>(label<font color="#666666">:string</font>) -> <font color="#666666">int</font></tt></td><td class="a">(use im_tab_bar instead)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_tab_bar_end</b>()</tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_tab_start</b>(label<font color="#666666">:string</font>, flags<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">(use im_tab instead)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_tab_end</b>()</tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_menu_bar_start</b>(main<font color="#666666">:bool</font>) -> <font color="#666666">int</font></tt></td><td class="a">(use im_menu_bar instead)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_menu_bar_end</b>(main<font color="#666666">:bool</font>)</tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_menu_start</b>(label<font color="#666666">:string</font>, disabled<font color="#666666">:bool</font> = false) -> <font color="#666666">int</font></tt></td><td class="a">(use im_menu instead)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_menu_end</b>()</tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_menu_item</b>(label<font color="#666666">:string</font>, shortcut<font color="#666666">:string</font> = nil, disabled<font color="#666666">:bool</font> = false) -> <font color="#666666">int</font></tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_menu_item_toggle</b>(label<font color="#666666">:string</font>, selected<font color="#666666">:bool</font> = false, disabled<font color="#666666">:bool</font> = false) -> <font color="#666666">int</font></tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_id_start</b>(label<font color="#666666">:string</font>)</tt></td><td class="a">an invisble group around some widgets, useful to ensure these widgets are unique (if they have the same label as widgets in another group that has a different group label). Use im_id instead</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_id_end</b>()</tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_child_start</b>(title<font color="#666666">:string</font>, size<font color="#666666">:float2</font>, flags<font color="#666666">:int</font>)</tt></td><td class="a">create a self-contained scrolling/clipping region with a window. use im_child instead</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_child_end</b>()</tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_group_start</b>()</tt></td><td class="a">lock the horizontal starting position, and capture all contained widgets into one item. Use im_group instead</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_group_end</b>()</tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_popup_start</b>(label<font color="#666666">:string</font>, winflags<font color="#666666">:int</font>, rmbprevitem<font color="#666666">:bool</font> = false) -> <font color="#666666">int</font></tt></td><td class="a">(use im_popup instead)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_popup_end</b>()</tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_popup_open</b>(label<font color="#666666">:string</font>)</tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_close_current_popup</b>()</tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_disabled_start</b>(disabled<font color="#666666">:bool</font>)</tt></td><td class="a">(use im_disabled instead)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_disabled_end</b>()</tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_width_start</b>(width<font color="#666666">:float</font>)</tt></td><td class="a">Sets the width of an item: 0 = default, -1 = use full width without label, any other value is custom width. Use im_width instead</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_width_end</b>()</tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_text_table</b>(id<font color="#666666">:string</font>, num_colums<font color="#666666">:int</font>, labels<font color="#666666">:[string]</font>)</tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_edit_anything</b>(value<font color="#666666"></font>, label<font color="#666666">:string</font> = nil) -> <font color="#666666">any</font></tt></td><td class="a">creates a UI for any lobster reference value, and returns the edited version</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_graph</b>(label<font color="#666666">:string</font>, values<font color="#666666">:[float]</font>, ishistogram<font color="#666666">:int</font>)</tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_show_vars</b>()</tt></td><td class="a">shows an automatic editing UI for each global variable in your program</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>im_show_engine_stats</b>()</tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>breakpoint</b>(condition<font color="#666666">:int</font>)</tt></td><td class="a">stops the program in the debugger if passed true. debugger needs --runtime-verbose on, and im_init() to have run.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>breakpoint</b>()</tt></td><td class="a">stops the program in the debugger always. debugger needs --runtime-verbose on, and im_init() to have run.</td></tr>
</table>
</td></tr></table></center></body>
</html>
