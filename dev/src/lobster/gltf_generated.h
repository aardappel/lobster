// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_GLTF_GLTF_H_
#define FLATBUFFERS_GENERATED_GLTF_GLTF_H_

#include "flatbuffers/flatbuffers.h"

namespace gltf {

struct Asset;

struct Scene;

struct Node;

struct Target;

struct Channel;

struct Sampler;

struct Animation;

struct ColorTexture;

struct MetallicRoughness;

struct Material;

struct Attributes;

struct Primitive;

struct Mesh;

struct Texture;

struct Image;

struct Accessor;

struct BufferView;

struct Buffer;

struct GLTF;

enum Interpolation {
  Interpolation_LINEAR = 0,
  Interpolation_MIN = Interpolation_LINEAR,
  Interpolation_MAX = Interpolation_LINEAR
};

inline const Interpolation (&EnumValuesInterpolation())[1] {
  static const Interpolation values[] = {
    Interpolation_LINEAR
  };
  return values;
}

inline const char * const *EnumNamesInterpolation() {
  static const char * const names[] = {
    "LINEAR",
    nullptr
  };
  return names;
}

inline const char *EnumNameInterpolation(Interpolation e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesInterpolation()[index];
}

enum AccessorType {
  AccessorType_SCALAR = 0,
  AccessorType_VEC2 = 1,
  AccessorType_VEC3 = 2,
  AccessorType_VEC4 = 3,
  AccessorType_MIN = AccessorType_SCALAR,
  AccessorType_MAX = AccessorType_VEC4
};

inline const AccessorType (&EnumValuesAccessorType())[4] {
  static const AccessorType values[] = {
    AccessorType_SCALAR,
    AccessorType_VEC2,
    AccessorType_VEC3,
    AccessorType_VEC4
  };
  return values;
}

inline const char * const *EnumNamesAccessorType() {
  static const char * const names[] = {
    "SCALAR",
    "VEC2",
    "VEC3",
    "VEC4",
    nullptr
  };
  return names;
}

inline const char *EnumNameAccessorType(AccessorType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesAccessorType()[index];
}

struct Asset FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_GENERATOR = 4,
    VT_VERSION = 6
  };
  const flatbuffers::String *generator() const {
    return GetPointer<const flatbuffers::String *>(VT_GENERATOR);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_GENERATOR) &&
           verifier.VerifyString(generator()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.VerifyString(version()) &&
           verifier.EndTable();
  }
};

struct AssetBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_generator(flatbuffers::Offset<flatbuffers::String> generator) {
    fbb_.AddOffset(Asset::VT_GENERATOR, generator);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(Asset::VT_VERSION, version);
  }
  explicit AssetBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AssetBuilder &operator=(const AssetBuilder &);
  flatbuffers::Offset<Asset> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Asset>(end);
    return o;
  }
};

inline flatbuffers::Offset<Asset> CreateAsset(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> generator = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0) {
  AssetBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_generator(generator);
  return builder_.Finish();
}

inline flatbuffers::Offset<Asset> CreateAssetDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *generator = nullptr,
    const char *version = nullptr) {
  return gltf::CreateAsset(
      _fbb,
      generator ? _fbb.CreateString(generator) : 0,
      version ? _fbb.CreateString(version) : 0);
}

struct Scene FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_NODES = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<int32_t> *nodes() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_NODES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_NODES) &&
           verifier.VerifyVector(nodes()) &&
           verifier.EndTable();
  }
};

struct SceneBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Scene::VT_NAME, name);
  }
  void add_nodes(flatbuffers::Offset<flatbuffers::Vector<int32_t>> nodes) {
    fbb_.AddOffset(Scene::VT_NODES, nodes);
  }
  explicit SceneBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SceneBuilder &operator=(const SceneBuilder &);
  flatbuffers::Offset<Scene> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Scene>(end);
    return o;
  }
};

inline flatbuffers::Offset<Scene> CreateScene(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> nodes = 0) {
  SceneBuilder builder_(_fbb);
  builder_.add_nodes(nodes);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Scene> CreateSceneDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<int32_t> *nodes = nullptr) {
  return gltf::CreateScene(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      nodes ? _fbb.CreateVector<int32_t>(*nodes) : 0);
}

struct Node FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MESH = 4,
    VT_NAME = 6,
    VT_CHILDREN = 8,
    VT_TRANSLATION = 10,
    VT_ROTATION = 12,
    VT_SCALE = 14
  };
  int32_t mesh() const {
    return GetField<int32_t>(VT_MESH, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<int32_t> *children() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_CHILDREN);
  }
  const flatbuffers::Vector<float> *translation() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_TRANSLATION);
  }
  const flatbuffers::Vector<float> *rotation() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_ROTATION);
  }
  const flatbuffers::Vector<float> *scale() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_SCALE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_MESH) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_CHILDREN) &&
           verifier.VerifyVector(children()) &&
           VerifyOffset(verifier, VT_TRANSLATION) &&
           verifier.VerifyVector(translation()) &&
           VerifyOffset(verifier, VT_ROTATION) &&
           verifier.VerifyVector(rotation()) &&
           VerifyOffset(verifier, VT_SCALE) &&
           verifier.VerifyVector(scale()) &&
           verifier.EndTable();
  }
};

struct NodeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mesh(int32_t mesh) {
    fbb_.AddElement<int32_t>(Node::VT_MESH, mesh, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Node::VT_NAME, name);
  }
  void add_children(flatbuffers::Offset<flatbuffers::Vector<int32_t>> children) {
    fbb_.AddOffset(Node::VT_CHILDREN, children);
  }
  void add_translation(flatbuffers::Offset<flatbuffers::Vector<float>> translation) {
    fbb_.AddOffset(Node::VT_TRANSLATION, translation);
  }
  void add_rotation(flatbuffers::Offset<flatbuffers::Vector<float>> rotation) {
    fbb_.AddOffset(Node::VT_ROTATION, rotation);
  }
  void add_scale(flatbuffers::Offset<flatbuffers::Vector<float>> scale) {
    fbb_.AddOffset(Node::VT_SCALE, scale);
  }
  explicit NodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NodeBuilder &operator=(const NodeBuilder &);
  flatbuffers::Offset<Node> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Node>(end);
    return o;
  }
};

inline flatbuffers::Offset<Node> CreateNode(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t mesh = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> children = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> translation = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> rotation = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> scale = 0) {
  NodeBuilder builder_(_fbb);
  builder_.add_scale(scale);
  builder_.add_rotation(rotation);
  builder_.add_translation(translation);
  builder_.add_children(children);
  builder_.add_name(name);
  builder_.add_mesh(mesh);
  return builder_.Finish();
}

inline flatbuffers::Offset<Node> CreateNodeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t mesh = 0,
    const char *name = nullptr,
    const std::vector<int32_t> *children = nullptr,
    const std::vector<float> *translation = nullptr,
    const std::vector<float> *rotation = nullptr,
    const std::vector<float> *scale = nullptr) {
  return gltf::CreateNode(
      _fbb,
      mesh,
      name ? _fbb.CreateString(name) : 0,
      children ? _fbb.CreateVector<int32_t>(*children) : 0,
      translation ? _fbb.CreateVector<float>(*translation) : 0,
      rotation ? _fbb.CreateVector<float>(*rotation) : 0,
      scale ? _fbb.CreateVector<float>(*scale) : 0);
}

struct Target FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NODE = 4,
    VT_PATH = 6
  };
  int32_t node() const {
    return GetField<int32_t>(VT_NODE, 0);
  }
  const flatbuffers::String *path() const {
    return GetPointer<const flatbuffers::String *>(VT_PATH);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NODE) &&
           VerifyOffset(verifier, VT_PATH) &&
           verifier.VerifyString(path()) &&
           verifier.EndTable();
  }
};

struct TargetBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node(int32_t node) {
    fbb_.AddElement<int32_t>(Target::VT_NODE, node, 0);
  }
  void add_path(flatbuffers::Offset<flatbuffers::String> path) {
    fbb_.AddOffset(Target::VT_PATH, path);
  }
  explicit TargetBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TargetBuilder &operator=(const TargetBuilder &);
  flatbuffers::Offset<Target> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Target>(end);
    return o;
  }
};

inline flatbuffers::Offset<Target> CreateTarget(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t node = 0,
    flatbuffers::Offset<flatbuffers::String> path = 0) {
  TargetBuilder builder_(_fbb);
  builder_.add_path(path);
  builder_.add_node(node);
  return builder_.Finish();
}

inline flatbuffers::Offset<Target> CreateTargetDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t node = 0,
    const char *path = nullptr) {
  return gltf::CreateTarget(
      _fbb,
      node,
      path ? _fbb.CreateString(path) : 0);
}

struct Channel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SAMPLER = 4,
    VT_TARGET = 6
  };
  int32_t sampler() const {
    return GetField<int32_t>(VT_SAMPLER, 0);
  }
  const Target *target() const {
    return GetPointer<const Target *>(VT_TARGET);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SAMPLER) &&
           VerifyOffset(verifier, VT_TARGET) &&
           verifier.VerifyTable(target()) &&
           verifier.EndTable();
  }
};

struct ChannelBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sampler(int32_t sampler) {
    fbb_.AddElement<int32_t>(Channel::VT_SAMPLER, sampler, 0);
  }
  void add_target(flatbuffers::Offset<Target> target) {
    fbb_.AddOffset(Channel::VT_TARGET, target);
  }
  explicit ChannelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ChannelBuilder &operator=(const ChannelBuilder &);
  flatbuffers::Offset<Channel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Channel>(end);
    return o;
  }
};

inline flatbuffers::Offset<Channel> CreateChannel(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t sampler = 0,
    flatbuffers::Offset<Target> target = 0) {
  ChannelBuilder builder_(_fbb);
  builder_.add_target(target);
  builder_.add_sampler(sampler);
  return builder_.Finish();
}

struct Sampler FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_INPUT = 4,
    VT_INTERPOLATION = 6,
    VT_OUTPUT = 8
  };
  int32_t input() const {
    return GetField<int32_t>(VT_INPUT, 0);
  }
  Interpolation interpolation() const {
    return static_cast<Interpolation>(GetField<int16_t>(VT_INTERPOLATION, 0));
  }
  int32_t output() const {
    return GetField<int32_t>(VT_OUTPUT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_INPUT) &&
           VerifyField<int16_t>(verifier, VT_INTERPOLATION) &&
           VerifyField<int32_t>(verifier, VT_OUTPUT) &&
           verifier.EndTable();
  }
};

struct SamplerBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_input(int32_t input) {
    fbb_.AddElement<int32_t>(Sampler::VT_INPUT, input, 0);
  }
  void add_interpolation(Interpolation interpolation) {
    fbb_.AddElement<int16_t>(Sampler::VT_INTERPOLATION, static_cast<int16_t>(interpolation), 0);
  }
  void add_output(int32_t output) {
    fbb_.AddElement<int32_t>(Sampler::VT_OUTPUT, output, 0);
  }
  explicit SamplerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SamplerBuilder &operator=(const SamplerBuilder &);
  flatbuffers::Offset<Sampler> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Sampler>(end);
    return o;
  }
};

inline flatbuffers::Offset<Sampler> CreateSampler(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t input = 0,
    Interpolation interpolation = Interpolation_LINEAR,
    int32_t output = 0) {
  SamplerBuilder builder_(_fbb);
  builder_.add_output(output);
  builder_.add_input(input);
  builder_.add_interpolation(interpolation);
  return builder_.Finish();
}

struct Animation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CHANNELS = 4,
    VT_NAME = 6,
    VT_SAMPLERS = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<Channel>> *channels() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Channel>> *>(VT_CHANNELS);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Sampler>> *samplers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Sampler>> *>(VT_SAMPLERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CHANNELS) &&
           verifier.VerifyVector(channels()) &&
           verifier.VerifyVectorOfTables(channels()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_SAMPLERS) &&
           verifier.VerifyVector(samplers()) &&
           verifier.VerifyVectorOfTables(samplers()) &&
           verifier.EndTable();
  }
};

struct AnimationBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_channels(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Channel>>> channels) {
    fbb_.AddOffset(Animation::VT_CHANNELS, channels);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Animation::VT_NAME, name);
  }
  void add_samplers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Sampler>>> samplers) {
    fbb_.AddOffset(Animation::VT_SAMPLERS, samplers);
  }
  explicit AnimationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnimationBuilder &operator=(const AnimationBuilder &);
  flatbuffers::Offset<Animation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Animation>(end);
    return o;
  }
};

inline flatbuffers::Offset<Animation> CreateAnimation(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Channel>>> channels = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Sampler>>> samplers = 0) {
  AnimationBuilder builder_(_fbb);
  builder_.add_samplers(samplers);
  builder_.add_name(name);
  builder_.add_channels(channels);
  return builder_.Finish();
}

inline flatbuffers::Offset<Animation> CreateAnimationDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Channel>> *channels = nullptr,
    const char *name = nullptr,
    const std::vector<flatbuffers::Offset<Sampler>> *samplers = nullptr) {
  return gltf::CreateAnimation(
      _fbb,
      channels ? _fbb.CreateVector<flatbuffers::Offset<Channel>>(*channels) : 0,
      name ? _fbb.CreateString(name) : 0,
      samplers ? _fbb.CreateVector<flatbuffers::Offset<Sampler>>(*samplers) : 0);
}

struct ColorTexture FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_INDEX = 4,
    VT_TEXCOORD = 6
  };
  int32_t index() const {
    return GetField<int32_t>(VT_INDEX, 0);
  }
  int32_t texCoord() const {
    return GetField<int32_t>(VT_TEXCOORD, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_INDEX) &&
           VerifyField<int32_t>(verifier, VT_TEXCOORD) &&
           verifier.EndTable();
  }
};

struct ColorTextureBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_index(int32_t index) {
    fbb_.AddElement<int32_t>(ColorTexture::VT_INDEX, index, 0);
  }
  void add_texCoord(int32_t texCoord) {
    fbb_.AddElement<int32_t>(ColorTexture::VT_TEXCOORD, texCoord, 0);
  }
  explicit ColorTextureBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ColorTextureBuilder &operator=(const ColorTextureBuilder &);
  flatbuffers::Offset<ColorTexture> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ColorTexture>(end);
    return o;
  }
};

inline flatbuffers::Offset<ColorTexture> CreateColorTexture(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t index = 0,
    int32_t texCoord = 0) {
  ColorTextureBuilder builder_(_fbb);
  builder_.add_texCoord(texCoord);
  builder_.add_index(index);
  return builder_.Finish();
}

struct MetallicRoughness FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_BASECOLORTEXTURE = 4,
    VT_METALLICFACTOR = 6,
    VT_ROUGHNESSFACTOR = 8
  };
  const ColorTexture *baseColorTexture() const {
    return GetPointer<const ColorTexture *>(VT_BASECOLORTEXTURE);
  }
  float metallicFactor() const {
    return GetField<float>(VT_METALLICFACTOR, 0.0f);
  }
  float roughnessFactor() const {
    return GetField<float>(VT_ROUGHNESSFACTOR, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BASECOLORTEXTURE) &&
           verifier.VerifyTable(baseColorTexture()) &&
           VerifyField<float>(verifier, VT_METALLICFACTOR) &&
           VerifyField<float>(verifier, VT_ROUGHNESSFACTOR) &&
           verifier.EndTable();
  }
};

struct MetallicRoughnessBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_baseColorTexture(flatbuffers::Offset<ColorTexture> baseColorTexture) {
    fbb_.AddOffset(MetallicRoughness::VT_BASECOLORTEXTURE, baseColorTexture);
  }
  void add_metallicFactor(float metallicFactor) {
    fbb_.AddElement<float>(MetallicRoughness::VT_METALLICFACTOR, metallicFactor, 0.0f);
  }
  void add_roughnessFactor(float roughnessFactor) {
    fbb_.AddElement<float>(MetallicRoughness::VT_ROUGHNESSFACTOR, roughnessFactor, 0.0f);
  }
  explicit MetallicRoughnessBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MetallicRoughnessBuilder &operator=(const MetallicRoughnessBuilder &);
  flatbuffers::Offset<MetallicRoughness> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MetallicRoughness>(end);
    return o;
  }
};

inline flatbuffers::Offset<MetallicRoughness> CreateMetallicRoughness(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<ColorTexture> baseColorTexture = 0,
    float metallicFactor = 0.0f,
    float roughnessFactor = 0.0f) {
  MetallicRoughnessBuilder builder_(_fbb);
  builder_.add_roughnessFactor(roughnessFactor);
  builder_.add_metallicFactor(metallicFactor);
  builder_.add_baseColorTexture(baseColorTexture);
  return builder_.Finish();
}

struct Material FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_PBRMETALLICROUGHNESS = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const MetallicRoughness *pbrMetallicRoughness() const {
    return GetPointer<const MetallicRoughness *>(VT_PBRMETALLICROUGHNESS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_PBRMETALLICROUGHNESS) &&
           verifier.VerifyTable(pbrMetallicRoughness()) &&
           verifier.EndTable();
  }
};

struct MaterialBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Material::VT_NAME, name);
  }
  void add_pbrMetallicRoughness(flatbuffers::Offset<MetallicRoughness> pbrMetallicRoughness) {
    fbb_.AddOffset(Material::VT_PBRMETALLICROUGHNESS, pbrMetallicRoughness);
  }
  explicit MaterialBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MaterialBuilder &operator=(const MaterialBuilder &);
  flatbuffers::Offset<Material> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Material>(end);
    return o;
  }
};

inline flatbuffers::Offset<Material> CreateMaterial(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<MetallicRoughness> pbrMetallicRoughness = 0) {
  MaterialBuilder builder_(_fbb);
  builder_.add_pbrMetallicRoughness(pbrMetallicRoughness);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Material> CreateMaterialDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    flatbuffers::Offset<MetallicRoughness> pbrMetallicRoughness = 0) {
  return gltf::CreateMaterial(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      pbrMetallicRoughness);
}

struct Attributes FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_POSITION = 4,
    VT_NORMAL = 6,
    VT_TANGENT = 8,
    VT_TEXCOORD_0 = 10
  };
  int32_t POSITION() const {
    return GetField<int32_t>(VT_POSITION, 0);
  }
  int32_t NORMAL() const {
    return GetField<int32_t>(VT_NORMAL, 0);
  }
  int32_t TANGENT() const {
    return GetField<int32_t>(VT_TANGENT, 0);
  }
  int32_t TEXCOORD_0() const {
    return GetField<int32_t>(VT_TEXCOORD_0, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_POSITION) &&
           VerifyField<int32_t>(verifier, VT_NORMAL) &&
           VerifyField<int32_t>(verifier, VT_TANGENT) &&
           VerifyField<int32_t>(verifier, VT_TEXCOORD_0) &&
           verifier.EndTable();
  }
};

struct AttributesBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_POSITION(int32_t POSITION) {
    fbb_.AddElement<int32_t>(Attributes::VT_POSITION, POSITION, 0);
  }
  void add_NORMAL(int32_t NORMAL) {
    fbb_.AddElement<int32_t>(Attributes::VT_NORMAL, NORMAL, 0);
  }
  void add_TANGENT(int32_t TANGENT) {
    fbb_.AddElement<int32_t>(Attributes::VT_TANGENT, TANGENT, 0);
  }
  void add_TEXCOORD_0(int32_t TEXCOORD_0) {
    fbb_.AddElement<int32_t>(Attributes::VT_TEXCOORD_0, TEXCOORD_0, 0);
  }
  explicit AttributesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AttributesBuilder &operator=(const AttributesBuilder &);
  flatbuffers::Offset<Attributes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Attributes>(end);
    return o;
  }
};

inline flatbuffers::Offset<Attributes> CreateAttributes(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t POSITION = 0,
    int32_t NORMAL = 0,
    int32_t TANGENT = 0,
    int32_t TEXCOORD_0 = 0) {
  AttributesBuilder builder_(_fbb);
  builder_.add_TEXCOORD_0(TEXCOORD_0);
  builder_.add_TANGENT(TANGENT);
  builder_.add_NORMAL(NORMAL);
  builder_.add_POSITION(POSITION);
  return builder_.Finish();
}

struct Primitive FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ATTRIBUTES = 4,
    VT_INDICES = 6,
    VT_MATERIAL = 8,
    VT_MODE = 10
  };
  const Attributes *attributes() const {
    return GetPointer<const Attributes *>(VT_ATTRIBUTES);
  }
  int32_t indices() const {
    return GetField<int32_t>(VT_INDICES, 0);
  }
  int32_t material() const {
    return GetField<int32_t>(VT_MATERIAL, 0);
  }
  int32_t mode() const {
    return GetField<int32_t>(VT_MODE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ATTRIBUTES) &&
           verifier.VerifyTable(attributes()) &&
           VerifyField<int32_t>(verifier, VT_INDICES) &&
           VerifyField<int32_t>(verifier, VT_MATERIAL) &&
           VerifyField<int32_t>(verifier, VT_MODE) &&
           verifier.EndTable();
  }
};

struct PrimitiveBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_attributes(flatbuffers::Offset<Attributes> attributes) {
    fbb_.AddOffset(Primitive::VT_ATTRIBUTES, attributes);
  }
  void add_indices(int32_t indices) {
    fbb_.AddElement<int32_t>(Primitive::VT_INDICES, indices, 0);
  }
  void add_material(int32_t material) {
    fbb_.AddElement<int32_t>(Primitive::VT_MATERIAL, material, 0);
  }
  void add_mode(int32_t mode) {
    fbb_.AddElement<int32_t>(Primitive::VT_MODE, mode, 0);
  }
  explicit PrimitiveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PrimitiveBuilder &operator=(const PrimitiveBuilder &);
  flatbuffers::Offset<Primitive> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Primitive>(end);
    return o;
  }
};

inline flatbuffers::Offset<Primitive> CreatePrimitive(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Attributes> attributes = 0,
    int32_t indices = 0,
    int32_t material = 0,
    int32_t mode = 0) {
  PrimitiveBuilder builder_(_fbb);
  builder_.add_mode(mode);
  builder_.add_material(material);
  builder_.add_indices(indices);
  builder_.add_attributes(attributes);
  return builder_.Finish();
}

struct Mesh FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_PRIMITIVES = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Primitive>> *primitives() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Primitive>> *>(VT_PRIMITIVES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_PRIMITIVES) &&
           verifier.VerifyVector(primitives()) &&
           verifier.VerifyVectorOfTables(primitives()) &&
           verifier.EndTable();
  }
};

struct MeshBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Mesh::VT_NAME, name);
  }
  void add_primitives(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Primitive>>> primitives) {
    fbb_.AddOffset(Mesh::VT_PRIMITIVES, primitives);
  }
  explicit MeshBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MeshBuilder &operator=(const MeshBuilder &);
  flatbuffers::Offset<Mesh> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Mesh>(end);
    return o;
  }
};

inline flatbuffers::Offset<Mesh> CreateMesh(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Primitive>>> primitives = 0) {
  MeshBuilder builder_(_fbb);
  builder_.add_primitives(primitives);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Mesh> CreateMeshDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<flatbuffers::Offset<Primitive>> *primitives = nullptr) {
  return gltf::CreateMesh(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      primitives ? _fbb.CreateVector<flatbuffers::Offset<Primitive>>(*primitives) : 0);
}

struct Texture FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SOURCE = 4
  };
  int32_t source() const {
    return GetField<int32_t>(VT_SOURCE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SOURCE) &&
           verifier.EndTable();
  }
};

struct TextureBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_source(int32_t source) {
    fbb_.AddElement<int32_t>(Texture::VT_SOURCE, source, 0);
  }
  explicit TextureBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TextureBuilder &operator=(const TextureBuilder &);
  flatbuffers::Offset<Texture> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Texture>(end);
    return o;
  }
};

inline flatbuffers::Offset<Texture> CreateTexture(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t source = 0) {
  TextureBuilder builder_(_fbb);
  builder_.add_source(source);
  return builder_.Finish();
}

struct Image FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MIMETYPE = 4,
    VT_NAME = 6,
    VT_URI = 8
  };
  const flatbuffers::String *mimeType() const {
    return GetPointer<const flatbuffers::String *>(VT_MIMETYPE);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *uri() const {
    return GetPointer<const flatbuffers::String *>(VT_URI);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MIMETYPE) &&
           verifier.VerifyString(mimeType()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_URI) &&
           verifier.VerifyString(uri()) &&
           verifier.EndTable();
  }
};

struct ImageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mimeType(flatbuffers::Offset<flatbuffers::String> mimeType) {
    fbb_.AddOffset(Image::VT_MIMETYPE, mimeType);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Image::VT_NAME, name);
  }
  void add_uri(flatbuffers::Offset<flatbuffers::String> uri) {
    fbb_.AddOffset(Image::VT_URI, uri);
  }
  explicit ImageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ImageBuilder &operator=(const ImageBuilder &);
  flatbuffers::Offset<Image> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Image>(end);
    return o;
  }
};

inline flatbuffers::Offset<Image> CreateImage(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> mimeType = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> uri = 0) {
  ImageBuilder builder_(_fbb);
  builder_.add_uri(uri);
  builder_.add_name(name);
  builder_.add_mimeType(mimeType);
  return builder_.Finish();
}

inline flatbuffers::Offset<Image> CreateImageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *mimeType = nullptr,
    const char *name = nullptr,
    const char *uri = nullptr) {
  return gltf::CreateImage(
      _fbb,
      mimeType ? _fbb.CreateString(mimeType) : 0,
      name ? _fbb.CreateString(name) : 0,
      uri ? _fbb.CreateString(uri) : 0);
}

struct Accessor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_BUFFERVIEW = 4,
    VT_BYTEOFFSET = 6,
    VT_COMPONENTTYPE = 8,
    VT_TYPE = 10,
    VT_COUNT = 12,
    VT_MAX = 14,
    VT_MIN = 16
  };
  int32_t bufferView() const {
    return GetField<int32_t>(VT_BUFFERVIEW, 0);
  }
  int32_t byteOffset() const {
    return GetField<int32_t>(VT_BYTEOFFSET, 0);
  }
  int32_t componentType() const {
    return GetField<int32_t>(VT_COMPONENTTYPE, 0);
  }
  const flatbuffers::String *type() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE);
  }
  int32_t count() const {
    return GetField<int32_t>(VT_COUNT, 0);
  }
  const flatbuffers::Vector<float> *max() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_MAX);
  }
  const flatbuffers::Vector<float> *min() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_MIN);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_BUFFERVIEW) &&
           VerifyField<int32_t>(verifier, VT_BYTEOFFSET) &&
           VerifyField<int32_t>(verifier, VT_COMPONENTTYPE) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyField<int32_t>(verifier, VT_COUNT) &&
           VerifyOffset(verifier, VT_MAX) &&
           verifier.VerifyVector(max()) &&
           VerifyOffset(verifier, VT_MIN) &&
           verifier.VerifyVector(min()) &&
           verifier.EndTable();
  }
};

struct AccessorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_bufferView(int32_t bufferView) {
    fbb_.AddElement<int32_t>(Accessor::VT_BUFFERVIEW, bufferView, 0);
  }
  void add_byteOffset(int32_t byteOffset) {
    fbb_.AddElement<int32_t>(Accessor::VT_BYTEOFFSET, byteOffset, 0);
  }
  void add_componentType(int32_t componentType) {
    fbb_.AddElement<int32_t>(Accessor::VT_COMPONENTTYPE, componentType, 0);
  }
  void add_type(flatbuffers::Offset<flatbuffers::String> type) {
    fbb_.AddOffset(Accessor::VT_TYPE, type);
  }
  void add_count(int32_t count) {
    fbb_.AddElement<int32_t>(Accessor::VT_COUNT, count, 0);
  }
  void add_max(flatbuffers::Offset<flatbuffers::Vector<float>> max) {
    fbb_.AddOffset(Accessor::VT_MAX, max);
  }
  void add_min(flatbuffers::Offset<flatbuffers::Vector<float>> min) {
    fbb_.AddOffset(Accessor::VT_MIN, min);
  }
  explicit AccessorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AccessorBuilder &operator=(const AccessorBuilder &);
  flatbuffers::Offset<Accessor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Accessor>(end);
    return o;
  }
};

inline flatbuffers::Offset<Accessor> CreateAccessor(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t bufferView = 0,
    int32_t byteOffset = 0,
    int32_t componentType = 0,
    flatbuffers::Offset<flatbuffers::String> type = 0,
    int32_t count = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> max = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> min = 0) {
  AccessorBuilder builder_(_fbb);
  builder_.add_min(min);
  builder_.add_max(max);
  builder_.add_count(count);
  builder_.add_type(type);
  builder_.add_componentType(componentType);
  builder_.add_byteOffset(byteOffset);
  builder_.add_bufferView(bufferView);
  return builder_.Finish();
}

inline flatbuffers::Offset<Accessor> CreateAccessorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t bufferView = 0,
    int32_t byteOffset = 0,
    int32_t componentType = 0,
    const char *type = nullptr,
    int32_t count = 0,
    const std::vector<float> *max = nullptr,
    const std::vector<float> *min = nullptr) {
  return gltf::CreateAccessor(
      _fbb,
      bufferView,
      byteOffset,
      componentType,
      type ? _fbb.CreateString(type) : 0,
      count,
      max ? _fbb.CreateVector<float>(*max) : 0,
      min ? _fbb.CreateVector<float>(*min) : 0);
}

struct BufferView FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_BUFFER = 4,
    VT_BYTELENGTH = 6,
    VT_BYTEOFFSET = 8,
    VT_BYTESTRIDE = 10
  };
  int32_t buffer() const {
    return GetField<int32_t>(VT_BUFFER, 0);
  }
  int32_t byteLength() const {
    return GetField<int32_t>(VT_BYTELENGTH, 0);
  }
  int32_t byteOffset() const {
    return GetField<int32_t>(VT_BYTEOFFSET, 0);
  }
  int32_t byteStride() const {
    return GetField<int32_t>(VT_BYTESTRIDE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_BUFFER) &&
           VerifyField<int32_t>(verifier, VT_BYTELENGTH) &&
           VerifyField<int32_t>(verifier, VT_BYTEOFFSET) &&
           VerifyField<int32_t>(verifier, VT_BYTESTRIDE) &&
           verifier.EndTable();
  }
};

struct BufferViewBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_buffer(int32_t buffer) {
    fbb_.AddElement<int32_t>(BufferView::VT_BUFFER, buffer, 0);
  }
  void add_byteLength(int32_t byteLength) {
    fbb_.AddElement<int32_t>(BufferView::VT_BYTELENGTH, byteLength, 0);
  }
  void add_byteOffset(int32_t byteOffset) {
    fbb_.AddElement<int32_t>(BufferView::VT_BYTEOFFSET, byteOffset, 0);
  }
  void add_byteStride(int32_t byteStride) {
    fbb_.AddElement<int32_t>(BufferView::VT_BYTESTRIDE, byteStride, 0);
  }
  explicit BufferViewBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BufferViewBuilder &operator=(const BufferViewBuilder &);
  flatbuffers::Offset<BufferView> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BufferView>(end);
    return o;
  }
};

inline flatbuffers::Offset<BufferView> CreateBufferView(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t buffer = 0,
    int32_t byteLength = 0,
    int32_t byteOffset = 0,
    int32_t byteStride = 0) {
  BufferViewBuilder builder_(_fbb);
  builder_.add_byteStride(byteStride);
  builder_.add_byteOffset(byteOffset);
  builder_.add_byteLength(byteLength);
  builder_.add_buffer(buffer);
  return builder_.Finish();
}

struct Buffer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_BYTELENGTH = 4,
    VT_URI = 6
  };
  int32_t byteLength() const {
    return GetField<int32_t>(VT_BYTELENGTH, 0);
  }
  const flatbuffers::String *uri() const {
    return GetPointer<const flatbuffers::String *>(VT_URI);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_BYTELENGTH) &&
           VerifyOffset(verifier, VT_URI) &&
           verifier.VerifyString(uri()) &&
           verifier.EndTable();
  }
};

struct BufferBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_byteLength(int32_t byteLength) {
    fbb_.AddElement<int32_t>(Buffer::VT_BYTELENGTH, byteLength, 0);
  }
  void add_uri(flatbuffers::Offset<flatbuffers::String> uri) {
    fbb_.AddOffset(Buffer::VT_URI, uri);
  }
  explicit BufferBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BufferBuilder &operator=(const BufferBuilder &);
  flatbuffers::Offset<Buffer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Buffer>(end);
    return o;
  }
};

inline flatbuffers::Offset<Buffer> CreateBuffer(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t byteLength = 0,
    flatbuffers::Offset<flatbuffers::String> uri = 0) {
  BufferBuilder builder_(_fbb);
  builder_.add_uri(uri);
  builder_.add_byteLength(byteLength);
  return builder_.Finish();
}

inline flatbuffers::Offset<Buffer> CreateBufferDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t byteLength = 0,
    const char *uri = nullptr) {
  return gltf::CreateBuffer(
      _fbb,
      byteLength,
      uri ? _fbb.CreateString(uri) : 0);
}

struct GLTF FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ASSET = 4,
    VT_SCENE = 6,
    VT_SCENES = 8,
    VT_NODES = 10,
    VT_ANIMATIONS = 12,
    VT_MATERIALS = 14,
    VT_MESHES = 16,
    VT_TEXTURES = 18,
    VT_IMAGES = 20,
    VT_ACCESSORS = 22,
    VT_BUFFERVIEWS = 24,
    VT_BUFFERS = 26
  };
  const Asset *asset() const {
    return GetPointer<const Asset *>(VT_ASSET);
  }
  int32_t scene() const {
    return GetField<int32_t>(VT_SCENE, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Scene>> *scenes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Scene>> *>(VT_SCENES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Node>> *nodes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Node>> *>(VT_NODES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Animation>> *animations() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Animation>> *>(VT_ANIMATIONS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Material>> *materials() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Material>> *>(VT_MATERIALS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Mesh>> *meshes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Mesh>> *>(VT_MESHES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Texture>> *textures() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Texture>> *>(VT_TEXTURES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Image>> *images() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Image>> *>(VT_IMAGES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Accessor>> *accessors() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Accessor>> *>(VT_ACCESSORS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<BufferView>> *bufferViews() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<BufferView>> *>(VT_BUFFERVIEWS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Buffer>> *buffers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Buffer>> *>(VT_BUFFERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ASSET) &&
           verifier.VerifyTable(asset()) &&
           VerifyField<int32_t>(verifier, VT_SCENE) &&
           VerifyOffset(verifier, VT_SCENES) &&
           verifier.VerifyVector(scenes()) &&
           verifier.VerifyVectorOfTables(scenes()) &&
           VerifyOffset(verifier, VT_NODES) &&
           verifier.VerifyVector(nodes()) &&
           verifier.VerifyVectorOfTables(nodes()) &&
           VerifyOffset(verifier, VT_ANIMATIONS) &&
           verifier.VerifyVector(animations()) &&
           verifier.VerifyVectorOfTables(animations()) &&
           VerifyOffset(verifier, VT_MATERIALS) &&
           verifier.VerifyVector(materials()) &&
           verifier.VerifyVectorOfTables(materials()) &&
           VerifyOffset(verifier, VT_MESHES) &&
           verifier.VerifyVector(meshes()) &&
           verifier.VerifyVectorOfTables(meshes()) &&
           VerifyOffset(verifier, VT_TEXTURES) &&
           verifier.VerifyVector(textures()) &&
           verifier.VerifyVectorOfTables(textures()) &&
           VerifyOffset(verifier, VT_IMAGES) &&
           verifier.VerifyVector(images()) &&
           verifier.VerifyVectorOfTables(images()) &&
           VerifyOffset(verifier, VT_ACCESSORS) &&
           verifier.VerifyVector(accessors()) &&
           verifier.VerifyVectorOfTables(accessors()) &&
           VerifyOffset(verifier, VT_BUFFERVIEWS) &&
           verifier.VerifyVector(bufferViews()) &&
           verifier.VerifyVectorOfTables(bufferViews()) &&
           VerifyOffset(verifier, VT_BUFFERS) &&
           verifier.VerifyVector(buffers()) &&
           verifier.VerifyVectorOfTables(buffers()) &&
           verifier.EndTable();
  }
};

struct GLTFBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_asset(flatbuffers::Offset<Asset> asset) {
    fbb_.AddOffset(GLTF::VT_ASSET, asset);
  }
  void add_scene(int32_t scene) {
    fbb_.AddElement<int32_t>(GLTF::VT_SCENE, scene, 0);
  }
  void add_scenes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Scene>>> scenes) {
    fbb_.AddOffset(GLTF::VT_SCENES, scenes);
  }
  void add_nodes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Node>>> nodes) {
    fbb_.AddOffset(GLTF::VT_NODES, nodes);
  }
  void add_animations(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Animation>>> animations) {
    fbb_.AddOffset(GLTF::VT_ANIMATIONS, animations);
  }
  void add_materials(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Material>>> materials) {
    fbb_.AddOffset(GLTF::VT_MATERIALS, materials);
  }
  void add_meshes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Mesh>>> meshes) {
    fbb_.AddOffset(GLTF::VT_MESHES, meshes);
  }
  void add_textures(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Texture>>> textures) {
    fbb_.AddOffset(GLTF::VT_TEXTURES, textures);
  }
  void add_images(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Image>>> images) {
    fbb_.AddOffset(GLTF::VT_IMAGES, images);
  }
  void add_accessors(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Accessor>>> accessors) {
    fbb_.AddOffset(GLTF::VT_ACCESSORS, accessors);
  }
  void add_bufferViews(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BufferView>>> bufferViews) {
    fbb_.AddOffset(GLTF::VT_BUFFERVIEWS, bufferViews);
  }
  void add_buffers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Buffer>>> buffers) {
    fbb_.AddOffset(GLTF::VT_BUFFERS, buffers);
  }
  explicit GLTFBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GLTFBuilder &operator=(const GLTFBuilder &);
  flatbuffers::Offset<GLTF> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GLTF>(end);
    return o;
  }
};

inline flatbuffers::Offset<GLTF> CreateGLTF(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Asset> asset = 0,
    int32_t scene = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Scene>>> scenes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Node>>> nodes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Animation>>> animations = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Material>>> materials = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Mesh>>> meshes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Texture>>> textures = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Image>>> images = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Accessor>>> accessors = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BufferView>>> bufferViews = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Buffer>>> buffers = 0) {
  GLTFBuilder builder_(_fbb);
  builder_.add_buffers(buffers);
  builder_.add_bufferViews(bufferViews);
  builder_.add_accessors(accessors);
  builder_.add_images(images);
  builder_.add_textures(textures);
  builder_.add_meshes(meshes);
  builder_.add_materials(materials);
  builder_.add_animations(animations);
  builder_.add_nodes(nodes);
  builder_.add_scenes(scenes);
  builder_.add_scene(scene);
  builder_.add_asset(asset);
  return builder_.Finish();
}

inline flatbuffers::Offset<GLTF> CreateGLTFDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Asset> asset = 0,
    int32_t scene = 0,
    const std::vector<flatbuffers::Offset<Scene>> *scenes = nullptr,
    const std::vector<flatbuffers::Offset<Node>> *nodes = nullptr,
    const std::vector<flatbuffers::Offset<Animation>> *animations = nullptr,
    const std::vector<flatbuffers::Offset<Material>> *materials = nullptr,
    const std::vector<flatbuffers::Offset<Mesh>> *meshes = nullptr,
    const std::vector<flatbuffers::Offset<Texture>> *textures = nullptr,
    const std::vector<flatbuffers::Offset<Image>> *images = nullptr,
    const std::vector<flatbuffers::Offset<Accessor>> *accessors = nullptr,
    const std::vector<flatbuffers::Offset<BufferView>> *bufferViews = nullptr,
    const std::vector<flatbuffers::Offset<Buffer>> *buffers = nullptr) {
  return gltf::CreateGLTF(
      _fbb,
      asset,
      scene,
      scenes ? _fbb.CreateVector<flatbuffers::Offset<Scene>>(*scenes) : 0,
      nodes ? _fbb.CreateVector<flatbuffers::Offset<Node>>(*nodes) : 0,
      animations ? _fbb.CreateVector<flatbuffers::Offset<Animation>>(*animations) : 0,
      materials ? _fbb.CreateVector<flatbuffers::Offset<Material>>(*materials) : 0,
      meshes ? _fbb.CreateVector<flatbuffers::Offset<Mesh>>(*meshes) : 0,
      textures ? _fbb.CreateVector<flatbuffers::Offset<Texture>>(*textures) : 0,
      images ? _fbb.CreateVector<flatbuffers::Offset<Image>>(*images) : 0,
      accessors ? _fbb.CreateVector<flatbuffers::Offset<Accessor>>(*accessors) : 0,
      bufferViews ? _fbb.CreateVector<flatbuffers::Offset<BufferView>>(*bufferViews) : 0,
      buffers ? _fbb.CreateVector<flatbuffers::Offset<Buffer>>(*buffers) : 0);
}

inline const gltf::GLTF *GetGLTF(const void *buf) {
  return flatbuffers::GetRoot<gltf::GLTF>(buf);
}

inline const gltf::GLTF *GetSizePrefixedGLTF(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<gltf::GLTF>(buf);
}

inline bool VerifyGLTFBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<gltf::GLTF>(nullptr);
}

inline bool VerifySizePrefixedGLTFBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<gltf::GLTF>(nullptr);
}

inline void FinishGLTFBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<gltf::GLTF> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedGLTFBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<gltf::GLTF> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace gltf

#endif  // FLATBUFFERS_GENERATED_GLTF_GLTF_H_
