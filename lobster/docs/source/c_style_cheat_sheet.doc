title: Lobster C-style Language Cheat Sheet
output: c_style_cheat_sheet

! Basics

Because most programmers have prior knowledge of a C-style language (C, Go,
JavaScript, etc.), a good way to learn Lobster is by seeing how it differs from
what may be familiar. In the examples below, C# will be chosen by
default where C-style languages differ. If a particular example uses multiple
languages, that example's note will list what was used.

# Assign an existing variable.
` a = 1 `
` int a = 1; `

# Create a new variable, type through inference.
` var a = 1 `
` int a = 1; `

# Create a new constant, type through inference.
` let a = 1 `
` const int a = 1; `

#
` let a, b = 1, 2 `
` int a = 1; int b = 2; `

# The type of <code>Vector</code> is inferred.
# Vectors in lobster are also resizable, they're more similar to a C# <code>List</code>
# than an array.
` let v = [ 1, 2, 3 ] `
` int[] w = new int[3];
for (int i = 0; i < 3; i++) w[i] = v[i] + v[i]; `

# <code>nil</code> is more strict in Lobster, in that a reference type which can be <code>nil</code> is
# different from a reference type that is never <code>nil</code>. You must also explicitly convert
# between them.
` nil `
` null `

# These operators are functionally the most different. The bitwise operators
# from C-style languages are instead the functions <code>and()</code>,
# <code>or()</code>, <code>not()</code>.
` a | b & c `
` (a || b) && c `

# The <code>|</code> operator works slightly different to how you might expect.
# Rather than returning <code>true</code>, it returns whichever value was <code>true</code>
# (anything that is not <code>nil</code>, <code>false</code>,
# <code>0</code>, or <code>0.0</code>).
` let a = f() | g() `
` var a = f();
if (a == null) a = g(); `


! Control Structures

#
` if a: b else: c `
` if (a) b; else c `

#
`if a:
  b
  c
else:
  d
  e`
`if (a) {
  b;
  c;
} else {
  d;
  e;
}`

#
` for(m) i: print i `
` for (int i = 0; i < m; i++) print(i) `

#
` for m: print _`
` for (int i = 0; i < m; i++) print(i) `

#
` for(m) i:
  print i`
` for (int i = 0; i < m; i++) {
  print(i);
} `

#
` while a: b `
` while (a) b; `

#
` for(list) a: print a `
` foreach (var a in list) print(a); `

#
` let a = switch i:
  case 1: "no"
  case 2, 4..6: "yes"
  default: "maybe" `
` switch (i) {
  case 1:
    a = "no";
    break;
  case 2:
  case 4:
  case 5:
  case 6:
    a = "yes";
    break;
  default:
    a = "maybe";
} `

#
` let r = map(list) x: x * x `
` var r = new List();
foreach(var x in list) r.Add(x * x); `

# Most modern programming languages are able to use some form of lambdas that
# are similar, but not quite as powerful as the ones in Lobster
# (e.g., not being able to use <code>return</code> to break out of a loop).
` let r = map(list) x: x * x `
` var r = list.ConvertAll(x => x * x); `

#
` let r = filter list: _ > 0 `
` var r = new List();
foreach (var x in list) if (x > 0) r.Add(x); `

#
` let r = exists list: _ > 0 `
` var r = false;
foreach (var x in list) if (x > 0) { r = true; break; } `


! Functions & Scope

# In Lobster, it's unusual to specify types, especially the function return type.
# Lobster infers types by default.
` def name(a:int, b:int) -> int: return a + b`
` int name(int a, int b) { return a + b; }`

# By default, functions are declared without types.
# The type is automatically inferred on use.
` def name(a, b): a + b `
` T name<T>(T a, T b) { return a + b; }`

#
` def name(a, b):
  a + b `
` T name<T>(T a, T b) {
  return a + b;
} `

# Using <code>::</code> indicates a type for the argument, allowing you to access
# an object's elements directly, rather than writing something like <code>object.x</code>.
# This is similar to writing a method, though Lobster makes no such distinction.
` def magnitude(v::xy): sqrt(x * x + y * y) `
` // inside class xy
float magnitude() { return x * x + y * y; } `


# This is an equivalent way of writing the above when inside the scope of a
# class or struct <em>(see below)</em>.
` // inside class/struct xy
def magnitude(v::xy): sqrt(x * x + y * y) `
` // inside class xy
float magnitude() { return x * x + y * y; } `

# With function calls, you can move the first argument to the front of the call.
# This works for <em>any</em> function.
` v.magnitude()
magnitude(v)`
` v.magnitude() `

# Polymorphic functions <em>(virtual methods, dynamic dispatch)</em>
# in Lobster are created simply by writing multiple functions. These functions
# can work on user defined types or built-in ones. They can also be written separate
# from where the type was defined.
` def name(x:X, z:Z): 0
def name(x:X, w:W): 1
def name(x:Y, z:Z): 2`
`/* inside class X */ int name(B b) { return b.nameX(); }
/* inside class Y */ int name(Z z) { return 2; }
/* inside class Z */ int nameX() { return 0; }
/* inside class W */ int nameX() { return 1; } `


# Assigning a function to a variable compared to C#
` var f = def(a, b): a + b `
` var f = (int a, int b) => a + b `

# Assigning a function to a variable compared to C++
` let f = def(a, b): a + b `
` auto f = [](int a, int b) { return a + b; } `

# <em>Higher Order Functions (i.e. functions that take a function as an argument)</em> in Lobster
# can be written like so. In this example, <code>fold</code> takes a list <code>xs</code> and applies the function
# <code>fun</code> to each element. Each iteration "folds" the list into a single value.
` def fold(xs, init, fun):
  for(xs): init = fun(init, _)
  init `
` T fold<T>(List<T> xs, T init, Func<T, T, T> fun) {
  foreach (var x in xs) init = fun(init, x);
  return init;
} `

# Calling a function with a function value. Notice that <code>x</code> and <code>y</code> are the arguments of the
# function being passed into <code>fold</code>. This example sums all of the values in the list.
` let r = fold(list, 0) x, y: x + y `
` var r = fold(list, 0, (x, y) => x + y); `

# Anonymous arguments in lexical order. <em>(see <a href="" target="_blank">Language Reference</a>)</em>
` let r = fold(list, 0): _a + _b `
` var r = fold(list, 0, (a, b) => a + b); `

# In most other languages, lambda syntax becomes messy when used
# with larger bodies and looks different from the built-in control structures.
` let r = fold(list, 0) a, b:
  print a
  a + b `
` var r = fold(list, 0, (a, b) => {
  print(a);
  return a + b;
}); `

# In most other languages, you cannot <code>return</code> or <code>break</code>
# inside lambdas, often making them useless as control structures. In Lobster,
# they're functionally consistent with the built-in control structures. By default,
# <code>return</code> returns from the lexically enclosing named function.
` let r = fold(list, 0) a, b:
  if a < 0: return a
  a + b `
` /* not possible */ `

# <code>return</code> also allows you to specify which function to return <code>from</code>.
# In other languages, you can do with exception handling. Exception handling
# in Lobster is actually not a language feature, it's a group of utility functions <em>(try, catch, etc.)</em>
# implemented on top of <code>return</code> and <code>from</code>.<br />
` def f():
  g()
  0
def g():
  if something: return 1 from f
  0`
` int f() {
  try { g(); return 0; }
  catch (int x) { return x; }
}
int g() {
  if (something) throw 1;
  return 0;
}`


#
` def mret(): return 1, 2 `
` int mret(out int o) { o = 2; return 1; }`

#
` let a, b = mret() `
` var b; var a = mret(b); `


! User-Defined Types

#
` struct xy { x:float, y:float }`
` public struct xy { float x; float y; }`

# Generics
` struct xy { x, y } `
` public struct xy<T> { T x; T y; }`

#
` struct xyz: xy { z:float } `
` public struct xyz : xy { float z; }`

# In C#, you'd have to define a constructor for this to work.
` let v = xyz { 1, 0, 0 } `
` var v = new xyz(1, 0, 0) `

# Indendation-based syntax with an inline function definition.
# <code>this</code> is inferred automatically.
` struct xy:
  x:float
  y:float
  def magnitude():
    sqrt(x * x + y * y) `
` public class xy {
  float x;
  float y;
  float magnitude() {
    return x * x + y * y;
  }
}`


! Coroutines
# In Lobster, Coroutines are defined like any other iteration function (by calling a function value).
# This allows you to easily define iteration functions without having to decide how you want to use them.
# In other languages, "yield return" can only be called from the <code>myiter</code> function body,
# not from any functions called from it. Lobster has no such limitations.
` def myiter(fun):
  for(10) i: fun(i) `
` IEnumerable<T> myiter() {
  for (int i = 0; i < 10; i++) yield return i;
}`

#
` let co = coroutine myiter() `
` var co = myiter() `

# Getting the last value produced by a coroutine, or in Lobster's case, also the value returned at the end.
` co.return_value `
` co.Current `

# Getting the next value from a coroutine.
` co.resume `
` co.MoveNext `

# Getting a coroutine to produce the next value, returning <code>x</code>
# from the function call that yielded the coroutine last.
` co.resume(x) `
` /* not available */ `

# Getting a coroutine to produce the next value, returning the argument to the function call.
` var r = co.resume `
` /* not available */ `

# In C#, MoveNext returns a <code>boolean</code> value that is can be equivalent.
` co.active `
` /* not available */ `

# Accessing local variables inside a coroutine object.
# This features makes it easier for multiple coroutines to communicate.
` co->i `
` /* not available */ `
