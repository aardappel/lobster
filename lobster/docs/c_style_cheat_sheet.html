<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Lobster C-style Language Cheat Sheet</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="github.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Lobster C-style Language Cheat Sheet</h1>
</header>
<p>Because most programmers have prior knowledge of a C-style language (C, Go, JavaScript, etc.), a good way to learn Lobster is by seeing how it differs from what may be familiar. In the examples below, C# will be chosen by default where C-style languages differ. If a particular example uses multiple languages, that example’s notes will list what was used.</p>
<!-- Table formatting fix -->
<style>
tbody { vertical-align: top; }
td { min-width: 250px; text-align: justify; }
.example { background: none; border: none; }
</style>
<!-- The examples in this doc were converted using a tool (lobster_to_md.lobster) -->
<h2 id="basics">Basics</h2>
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 37%" />
<col style="width: 47%" />
</colgroup>
<thead>
<tr class="header">
<th>Lobster Version</th>
<th>C-Style Version</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code class='example'>a = 1</code></td>
<td><code class='example'>int a = 1;</code></td>
<td>Assign an existing variable.</td>
</tr>
<tr class="even">
<td><code class='example'>var a = 1</code></td>
<td><code class='example'>int a = 1;</code></td>
<td>Create a new variable, type through inference.</td>
</tr>
<tr class="odd">
<td><code class='example'>let a = 1</code></td>
<td><code class='example'>const int a = 1;</code></td>
<td>Create a new constant, type through inference.</td>
</tr>
<tr class="even">
<td><code class='example'>let a, b = 1, 2</code></td>
<td><code class='example'>int a = 1; int b = 2;</code></td>
<td></td>
</tr>
<tr class="odd">
<td><code class='example'>let v = [ 1, 2, 3 ]</code></td>
<td><code class='example'>int[] w = new int[3];<br />for (int i = 0; i &lt; 3; i++) w[i] = v[i] + v[i];</code></td>
<td>The type of <code>Vector</code> is inferred. Vectors in lobster are also resizable, they’re more similar to a C# <code>List</code> than an array.</td>
</tr>
<tr class="even">
<td><code class='example'>nil</code></td>
<td><code class='example'>null</code></td>
<td><code>nil</code> is more strict in Lobster, in that a reference type which can be <code>nil</code> is different from a reference type that is never <code>nil</code>. You must also explicitly convert between them.</td>
</tr>
<tr class="odd">
<td><code class='example'>a | b &amp; c</code></td>
<td><code class='example'>(a || b) &amp;&amp; c</code></td>
<td>These operators are functionally the most different. The bitwise operators from C-style languages are instead the functions <code>and()</code>, <code>or()</code>, <code>not()</code>.</td>
</tr>
<tr class="even">
<td><code class='example'>let a = f() | g()</code></td>
<td><code class='example'>var a = f();<br />if (a == null) a = g();</code></td>
<td>The <code>|</code> operator works slightly different to how you might expect. Rather than returning <code>true</code>, it returns whichever value was <code>true</code> (anything that is not <code>nil</code>, <code>false</code>, <code>0</code>, or <code>0.0</code>).</td>
</tr>
</tbody>
</table>
<h2 id="control-structures">Control Structures</h2>
<table>
<colgroup>
<col style="width: 22%" />
<col style="width: 59%" />
<col style="width: 17%" />
</colgroup>
<thead>
<tr class="header">
<th>Lobster Version</th>
<th>C-Style Version</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code class='example'>if a: b else: c</code></td>
<td><code class='example'>if (a) b; else c</code></td>
<td></td>
</tr>
<tr class="even">
<td><code class='example'>if a:<br />     b<br />     c<br /> else:<br />     d<br />     e</code></td>
<td><code class='example'>if (a) {<br />  b;<br />  c;<br />} else {<br />  d;<br />  e;<br />}</code></td>
<td></td>
</tr>
<tr class="odd">
<td><code class='example'>for(m) i: print i</code></td>
<td><code class='example'>for (int i = 0; i &lt; m; i++) print(i)</code></td>
<td></td>
</tr>
<tr class="even">
<td><code class='example'>for m: print _</code></td>
<td><code class='example'>for (int i = 0; i &lt; m; i++) print(i)</code></td>
<td></td>
</tr>
<tr class="odd">
<td><code class='example'>for(m) i:<br />    print i</code></td>
<td><code class='example'>for (int i = 0; i &lt; m; i++) {<br />    print(i);<br />}</code></td>
<td></td>
</tr>
<tr class="even">
<td><code class='example'>while a: b</code></td>
<td><code class='example'>while (a) b;</code></td>
<td></td>
</tr>
<tr class="odd">
<td><code class='example'>for(list) a: print a</code></td>
<td><code class='example'>foreach (var a in list) print(a);</code></td>
<td></td>
</tr>
<tr class="even">
<td><code class='example'>let a = switch i:<br />    case 1: “no”<br />    case 2, 4..6: “yes”<br />    default: “maybe”</code></td>
<td><code class='example'>switch (i) {<br />    case 1:<br />        a = “no”;<br />        break;<br />    case 2:<br />    case 4:<br />    case 5:<br />    case 6:<br />        a = “yes”;<br />        break;<br />    default:<br />        a = “maybe”;<br />}</code></td>
<td></td>
</tr>
<tr class="odd">
<td><code class='example'>let r = map(list) x: x * x</code></td>
<td><code class='example'>var r = new List();<br />foreach(var x in list) r.Add(x * x);</code></td>
<td></td>
</tr>
<tr class="even">
<td><code class='example'>let r = map(list) x: x * x</code></td>
<td><code class='example'>var r = list.ConvertAll(x =&gt; x * x);</code></td>
<td>Most modern programming languages are able to use some form of lambdas that are similar, but not quite as powerful as the ones in Lobster (e.g., not being able to use <code>return</code> to break out of a loop).</td>
</tr>
<tr class="odd">
<td><code class='example'>let r = filter list: _ &gt; 0</code></td>
<td><code class='example'>var r = new List();<br />foreach (var x in list) if (x &gt; 0) r.Add(x);</code></td>
<td></td>
</tr>
<tr class="even">
<td><code class='example'>let r = exists list: _ &gt; 0</code></td>
<td><code class='example'>var r = false;<br />foreach (var x in list) if (x &gt; 0) { r = true; break; }</code></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="functions-scope">Functions &amp; Scope</h2>
<table>
<colgroup>
<col style="width: 23%" />
<col style="width: 45%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr class="header">
<th>Lobster Version</th>
<th>C-Style Version</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code class='example'>def name(a:int, b:int) ‐&gt; int: return a + b</code></td>
<td><code class='example'>int name(int a, int b) { return a + b; }</code></td>
<td>In Lobster, it’s unusual to specify types, especially the function return type. Lobster infers types by default.</td>
</tr>
<tr class="even">
<td><code class='example'>def name(a, b): return a + b</code></td>
<td><code class='example'>T name&lt;T&gt;(T a, T b) { return a + b; }</code></td>
<td>By default, functions are declared without types. The type is automatically inferred on use.</td>
</tr>
<tr class="odd">
<td><code class='example'>def name(a, b):<br />    return a + b</code></td>
<td><code class='example'>T name&lt;T&gt;(T a, T b) {<br />    return a + b;<br />}</code></td>
<td>By default, functions are declared without types. The type is automatically inferred on use.</td>
</tr>
<tr class="even">
<td><code class='example'>def magnitude(v::xy): sqrt(x * x + y * y)</code></td>
<td><code class='example'>// inside class xy<br />float magnitude() { return x * x + y * y; }</code></td>
<td>Using <code>::</code> indicates a type for the argument, allowing you to access an object’s elements directly, rather than writing something like <code>object.x</code>. This is similar to writing a method, though Lobster makes no such distinction.</td>
</tr>
<tr class="odd">
<td><code class='example'>// outside class/struct xy<br />def magnitude(v::xy): sqrt(x * x + y * y)</code></td>
<td><code class='example'>// inside class xy<br />float magnitude() { return x * x + y * y; }</code></td>
<td>This is an equivalent way of writing the above when not inside the scope of a class or struct <em>(see below)</em>.</td>
</tr>
<tr class="even">
<td><code class='example'>v.magnitude()<br />magnitude(v)</code></td>
<td><code class='example'>v.magnitude()</code></td>
<td>With function calls, you can move the first argument to the front of the call. This works for <em>any</em> function.</td>
</tr>
<tr class="odd">
<td><code class='example'>def name(x:X, z:Z): return 0<br />def name(x:X, w:W): return 1<br />def name(x:Y, z:Z): return 2</code></td>
<td><code class='example'>/* inside class X */ int name(B b) { return b.nameX(); }<br />/* inside class Y */ int name(Z z) { return 2; }<br />/* inside class Z */ int nameX() { return 0; }<br />/* inside class W */ int nameX() { return 1; }</code></td>
<td>Polymorphic functions <em>(virtual methods, dynamic dispatch, non-static overloading)</em> in Lobster are created simply by writing multiple functions. These functions can work on user defined types or built-in ones. They can also be written separate from where the type was defined.</td>
</tr>
<tr class="even">
<td><code class='example'>let f = def(a, b): a + b</code></td>
<td><code class='example'>var f = (int a, int b) =&gt; a + b</code></td>
<td>Assigning a function to a variable (compared to C#). Notice that the function doesn’t require an explicit <code>return</code> statement.</td>
</tr>
<tr class="odd">
<td><code class='example'>let f = def(a, b): a + b</code></td>
<td><code class='example'>auto f = <a href="int%20a,%20int%20b"></a> { return a + b; }</code></td>
<td>Assigning a function to a variable (compared to C++).</td>
</tr>
<tr class="even">
<td><code class='example'>def fold(xs, init, fun):<br />    for(xs): init = fun(init, _)<br />    init</code></td>
<td><code class='example'>T fold&lt;T&gt;(List&lt;T&gt; xs, T init, Func&lt;T, T, T&gt; fun) {<br />    foreach (var x in xs) init = fun(init, x);<br />    return init;<br />}</code></td>
<td><em>Higher Order Functions (i.e. functions that take a function as an argument)</em> in Lobster can be written like so. In this example, <code>fold</code> takes a list <code>xs</code> and applies the function <code>fun</code> to each element. Each iteration “folds” the list into a single value.</td>
</tr>
<tr class="odd">
<td><code class='example'>var r = fold(list, 0) x, y: x + y</code></td>
<td><code class='example'>var r = fold(list, 0, (x, y) =&gt; x + y);</code></td>
<td>Calling a function with a function value. Notice that <code>x</code> and <code>y</code> are the arguments of the function being passed into <code>fold</code>. This example sums all of the values in the list.</td>
</tr>
<tr class="even">
<td><code class='example'>var r = fold(list, 0): _a + _b</code></td>
<td><code class='example'>var r = fold(list, 0, (a, b) =&gt; a + b);</code></td>
<td>Anonymous arguments in lexical order. <em>(see <a href="language_reference.html" target="_blank">Language Reference</a>)</em></td>
</tr>
<tr class="odd">
<td><code class='example'>let r = fold(list, 0) a, b:<br />    print a<br />    a + b</code></td>
<td><code class='example'>var r = fold(list, 0, (a, b) =&gt; {<br />    print(a);<br />    return a + b;<br />});</code></td>
<td>In most other languages, lambda syntax becomes messy when used with larger bodies and looks different from the built-in control structures.</td>
</tr>
<tr class="even">
<td><code class='example'>let r = fold(list, 0) a, b:<br />    if a &lt; 0: return a<br />    a + b</code></td>
<td><code class='example'>/* not possible */</code></td>
<td>In most other languages, you cannot <code>return</code> or <code>break</code> inside lambdas, often making them useless as control structures. In Lobster, they’re functionally consistent with the built-in control structures. By default, <code>return</code> returns from the lexically enclosing named function.</td>
</tr>
<tr class="odd">
<td><code class='example'>def f():<br />    g()<br />    return 0<br />def g():<br />    if something: return 1 from f<br />    return 0</code></td>
<td><code class='example'>int f() {<br />    try { g(); return 0; }<br />    catch (int x) { return x; }<br />}<br />int g() {<br />    if (something) throw 1;<br />    return 0;<br />}</code></td>
<td><code>return</code> also allows you to specify which function to return <code>from</code>. In other languages, you can do with exception handling. Exception handling in Lobster is actually not a language feature, it’s a group of utility functions <em>(try, catch, etc.)</em> implemented on top of <code>return</code> and <code>from</code>.<br /></td>
</tr>
<tr class="even">
<td><code class='example'>def mret(): return 1, 2</code></td>
<td><code class='example'>int mret(out int o) { o = 2; return 1; }</code></td>
<td></td>
</tr>
<tr class="odd">
<td><code class='example'>let a, b = mret()</code></td>
<td><code class='example'>var b; var a = mret(b);</code></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="user-defined-types">User-Defined Types</h2>
<table>
<colgroup>
<col style="width: 36%" />
<col style="width: 49%" />
<col style="width: 13%" />
</colgroup>
<thead>
<tr class="header">
<th>Lobster Version</th>
<th>C-Style Version</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code class='example'>struct xy { x:float, y:float }</code></td>
<td><code class='example'>public struct xy { float x; float y; }</code></td>
<td></td>
</tr>
<tr class="even">
<td><code class='example'>struct xy { x, y }</code></td>
<td><code class='example'>public struct xy&lt;T&gt; { T x; T y; }</code></td>
<td>Generics</td>
</tr>
<tr class="odd">
<td><code class='example'>struct xyz: xy { z:float }</code></td>
<td><code class='example'>public struct xyz : xy { float z; }</code></td>
<td></td>
</tr>
<tr class="even">
<td><code class='example'>var v = xyz { 1, 0, 0 }</code></td>
<td><code class='example'>var v = new xyz(1, 0, 0)</code></td>
<td>In C#, you’d have to define a constructor for this to work.</td>
</tr>
<tr class="odd">
<td><code class='example'>struct xy:<br />    x:float<br />    y:float<br />    def magnitude():<br />        sqrt(x * x + y * y)</code></td>
<td><code class='example'>public class xy {<br />    float x;<br />    float y;<br />    float magnitude() {<br />        return x * x + y * y;<br />    }<br />}</code></td>
<td>Indentation-based syntax with an inline function definition. <code>this</code> is inferred automatically.</td>
</tr>
</tbody>
</table>
<h2 id="coroutines">Coroutines</h2>
<table>
<colgroup>
<col style="width: 15%" />
<col style="width: 31%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr class="header">
<th>Lobster Version</th>
<th>C-Style Version</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code class='example'>def myiter(fun):<br />    for(10) i: fun(i)</code></td>
<td><code class='example'>IEnumerable&lt;T&gt; myiter() {<br />    for (int i = 0; i &lt; 10; i++) yield return i;<br />}</code></td>
<td>In Lobster, Coroutines are defined like any other iteration function (by calling a function value). This allows you to easily define iteration functions without having to decide how you want to use them. In other languages, “yield return” can only be called from the <code>myiter</code> function body, not from any functions called from it. Lobster has no such limitations.</td>
</tr>
<tr class="even">
<td><code class='example'>let co = coroutine myiter()</code></td>
<td><code class='example'>var co = myiter()</code></td>
<td></td>
</tr>
<tr class="odd">
<td><code class='example'>co.return_value</code></td>
<td><code class='example'>co.Current</code></td>
<td>Getting the last value produced by a coroutine, or in Lobster’s case, also the value returned at the end.</td>
</tr>
<tr class="even">
<td><code class='example'>co.resume</code></td>
<td><code class='example'>co.MoveNext</code></td>
<td>Getting the next value from a coroutine.</td>
</tr>
<tr class="odd">
<td><code class='example'>co.resume(x)</code></td>
<td><code class='example'>/* not available */</code></td>
<td>Getting a coroutine to produce the next value, returning <code>x</code> from the function call that yielded the coroutine last.</td>
</tr>
<tr class="even">
<td><code class='example'>var r = co.resume</code></td>
<td><code class='example'>/* not available */</code></td>
<td>Getting a coroutine to produce the next value, returning the argument to the function call.</td>
</tr>
<tr class="odd">
<td><code class='example'>co.active</code></td>
<td><code class='example'>/* not available */</code></td>
<td>In C#, MoveNext returns a <code>boolean</code> value that is can be equivalent.</td>
</tr>
<tr class="even">
<td><code class='example'>co‐&gt;i</code></td>
<td><code class='example'>/* not available */</code></td>
<td>Accessing local variables inside a coroutine object. This features makes it easier for multiple coroutines to communicate.</td>
</tr>
</tbody>
</table>
</body>
</html>
