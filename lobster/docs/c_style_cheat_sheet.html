<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "https://www.w3.org/TR/html4/strict.dtd">
<html><head><meta content="text/html; charset=ISO-8859-1" http-equiv="content-type"><title>Lobster C-style Language Cheat Sheet</title>
<!--<link rel="stylesheet" type="text/css" href="docs/github.css">-->
<style type="text/css">
body { width: 90%; margin: 0 auto; padding-top: 50px; padding-bottom: 50px; }
table, tr, td { border: 1pt solid #DDDDDD; border-Collapse: collapse; max-width:1200px; vertical-align:top }
code { font-family: Consolas; background-color: #DDDDDD; padding: 1px 2px 1px 2px; }

td { font-family: Consolas; font-size: 0.8em; }

.table-doc { width: 100%; text-align: left; margin-left: auto; margin-right: auto; }
.table-header { font-weight: bold; font-size: 1em; }
.table-entry { font-family: Consolas; white-space: nowrap; }

.header-section { text-align: center; padding: 20pt; }
.header-section span { font-family: Consolas; font-size: 2em; }

.subheader-section { text-align: center; padding: 20pt; }
.subheader-section span { font-weight: bold; font-family: Consolas; font-size: 1.25em; }

.subtext { font-family: Consolas; font-size: 0.85em; text-align: justify; margin: 0 auto; padding-bottom: 20px; max-width: 1200px; }
</style>
</head>


<!-- DISCLAIMER: This document was generated by a program. It is not intended to be human readable, hopefully the docs are though :) -->


<body>
<!-- doc start -->
<!-- header start --><div class='header-section'><span>Lobster C-style Language Cheat Sheet</span></div><!-- header end --><!-- subheader start --><div class='subheader-section'><span>Basics</span></div><!-- subheader end --><!-- header subtext start --><p class='subtext'>Because most programmers have prior knowledge of a C-style language (C, Go, JavaScript, etc.), a good way to learn Lobster is by seeing how it differs from what may be familiar. In the examples below, C# will be chosen by default where C-style languages differ. If a particular example uses multiple languages, that example's note will list what was used.</p><!-- header subtext end --><!-- doc table start -->
<table class="table-doc" border="1" cellpadding="5" cellspacing="2"><tbody>
<tr>
<td class="table-header">Lobster Version</td>
<td class="table-header">C-style Version</td>
<td class="table-header">Notes</td>
</tr>
<tr><td class='table-entry'>a&nbsp;=&nbsp;1&nbsp;</td><td class='table-entry'>int&nbsp;a&nbsp;=&nbsp;1&semi;&nbsp;</td><td>Assign an existing variable.</td></tr><tr><td class='table-entry'>var&nbsp;a&nbsp;=&nbsp;1&nbsp;</td><td class='table-entry'>int&nbsp;a&nbsp;=&nbsp;1&semi;&nbsp;</td><td>Create a new variable, type through inference.</td></tr><tr><td class='table-entry'>let&nbsp;a&nbsp;=&nbsp;1&nbsp;</td><td class='table-entry'>const&nbsp;int&nbsp;a&nbsp;=&nbsp;1&semi;&nbsp;</td><td>Create a new constant, type through inference.</td></tr><tr><td class='table-entry'>let&nbsp;a,&nbsp;b&nbsp;=&nbsp;1,&nbsp;2&nbsp;</td><td class='table-entry'>int&nbsp;a&nbsp;=&nbsp;1&semi;&nbsp;int&nbsp;b&nbsp;=&nbsp;2&semi;&nbsp;</td><td></td></tr><tr><td class='table-entry'>let&nbsp;v&nbsp;=&nbsp;[&nbsp;1,&nbsp;2,&nbsp;3&nbsp;]&nbsp;</td><td class='table-entry'>int[]&nbsp;w&nbsp;=&nbsp;new&nbsp;int[3]&semi;<br />for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0&semi;&nbsp;i&nbsp;&lt;&nbsp;3&semi;&nbsp;i++)&nbsp;w[i]&nbsp;=&nbsp;v[i]&nbsp;+&nbsp;v[i]&semi;&nbsp;</td><td>The type of <code>Vector</code> is inferred. Vectors in lobster are also resizable, they're more similar to a C# <code>List</code> than an array.</td></tr><tr><td class='table-entry'>nil&nbsp;</td><td class='table-entry'>null&nbsp;</td><td><code>nil</code> is more strict in Lobster, in that a reference type which can be <code>nil</code> is different from a reference type that is never <code>nil</code>. You must also explicitly convert between them.</td></tr><tr><td class='table-entry'>a&nbsp;&vert;&nbsp;b&nbsp;&&nbsp;c&nbsp;</td><td class='table-entry'>(a&nbsp;&vert;&vert;&nbsp;b)&nbsp;&&&nbsp;c&nbsp;</td><td>These operators are functionally the most different. The bitwise operators from C-style languages are instead the functions <code>and()</code>, <code>or()</code>, <code>not()</code>.</td></tr><tr><td class='table-entry'>let&nbsp;a&nbsp;=&nbsp;f()&nbsp;&vert;&nbsp;g()&nbsp;</td><td class='table-entry'>var&nbsp;a&nbsp;=&nbsp;f()&semi;<br />if&nbsp;(a&nbsp;==&nbsp;null)&nbsp;a&nbsp;=&nbsp;g()&semi;&nbsp;</td><td>The <code>|</code> operator works slightly different to how you might expect. Rather than returning <code>true</code>, it returns whichever value was <code>true</code> (anything that is not <code>nil</code>, <code>false</code>, <code>0</code>, or <code>0.0</code>).</td></tr></tbody></table><!-- doc table end --><!-- subheader start --><div class='subheader-section'><span>Control Structures</span></div><!-- subheader end --><!-- doc table start -->
<table class="table-doc" border="1" cellpadding="5" cellspacing="2"><tbody>
<tr>
<td class="table-header">Lobster Version</td>
<td class="table-header">C-style Version</td>
<td class="table-header">Notes</td>
</tr>
<tr><td class='table-entry'>if&nbsp;a:&nbsp;b&nbsp;else:&nbsp;c&nbsp;</td><td class='table-entry'>if&nbsp;(a)&nbsp;b&semi;&nbsp;else&nbsp;c&nbsp;</td><td></td></tr><tr><td class='table-entry'>if&nbsp;a:<br />&nbsp;&nbsp;b<br />&nbsp;&nbsp;c<br />else:<br />&nbsp;&nbsp;d<br />&nbsp;&nbsp;e</td><td class='table-entry'>if&nbsp;(a)&nbsp;{<br />&nbsp;&nbsp;b&semi;<br />&nbsp;&nbsp;c&semi;<br />}&nbsp;else&nbsp;{<br />&nbsp;&nbsp;d&semi;<br />&nbsp;&nbsp;e&semi;<br />}</td><td></td></tr><tr><td class='table-entry'>for(m)&nbsp;i:&nbsp;print&nbsp;i&nbsp;</td><td class='table-entry'>for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0&semi;&nbsp;i&nbsp;&lt;&nbsp;m&semi;&nbsp;i++)&nbsp;print(i)&nbsp;</td><td></td></tr><tr><td class='table-entry'>for&nbsp;m:&nbsp;print&nbsp;&lowbar;</td><td class='table-entry'>for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0&semi;&nbsp;i&nbsp;&lt;&nbsp;m&semi;&nbsp;i++)&nbsp;print(i)&nbsp;</td><td></td></tr><tr><td class='table-entry'>for(m)&nbsp;i:<br />&nbsp;&nbsp;print&nbsp;i</td><td class='table-entry'>for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0&semi;&nbsp;i&nbsp;&lt;&nbsp;m&semi;&nbsp;i++)&nbsp;{<br />&nbsp;&nbsp;print(i)&semi;<br />}&nbsp;</td><td></td></tr><tr><td class='table-entry'>while&nbsp;a:&nbsp;b&nbsp;</td><td class='table-entry'>while&nbsp;(a)&nbsp;b&semi;&nbsp;</td><td></td></tr><tr><td class='table-entry'>for(list)&nbsp;a:&nbsp;print&nbsp;a&nbsp;</td><td class='table-entry'>foreach&nbsp;(var&nbsp;a&nbsp;in&nbsp;list)&nbsp;print(a)&semi;&nbsp;</td><td></td></tr><tr><td class='table-entry'>let&nbsp;a&nbsp;=&nbsp;switch&nbsp;i:<br />&nbsp;&nbsp;case&nbsp;1:&nbsp;"no"<br />&nbsp;&nbsp;case&nbsp;2,&nbsp;4..6:&nbsp;"yes"<br />&nbsp;&nbsp;default:&nbsp;"maybe"&nbsp;</td><td class='table-entry'>switch&nbsp;(i)&nbsp;{<br />&nbsp;&nbsp;case&nbsp;1:<br />&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;"no"&semi;<br />&nbsp;&nbsp;&nbsp;&nbsp;break&semi;<br />&nbsp;&nbsp;case&nbsp;2:<br />&nbsp;&nbsp;case&nbsp;4:<br />&nbsp;&nbsp;case&nbsp;5:<br />&nbsp;&nbsp;case&nbsp;6:<br />&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;"yes"&semi;<br />&nbsp;&nbsp;&nbsp;&nbsp;break&semi;<br />&nbsp;&nbsp;default:<br />&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;"maybe"&semi;<br />}&nbsp;</td><td></td></tr><tr><td class='table-entry'>let&nbsp;r&nbsp;=&nbsp;map(list)&nbsp;x:&nbsp;x&nbsp;*&nbsp;x&nbsp;</td><td class='table-entry'>var&nbsp;r&nbsp;=&nbsp;new&nbsp;List()&semi;<br />foreach(var&nbsp;x&nbsp;in&nbsp;list)&nbsp;r.Add(x&nbsp;*&nbsp;x)&semi;&nbsp;</td><td></td></tr><tr><td class='table-entry'>let&nbsp;r&nbsp;=&nbsp;map(list)&nbsp;x:&nbsp;x&nbsp;*&nbsp;x&nbsp;</td><td class='table-entry'>var&nbsp;r&nbsp;=&nbsp;list.ConvertAll(x&nbsp;=&gt;&nbsp;x&nbsp;*&nbsp;x)&semi;&nbsp;</td><td>Most modern programming languages are able to use some form of lambdas that are similar, but not quite as powerful as the ones in Lobster (e.g., not being able to use <code>return</code> to break out of a loop).</td></tr><tr><td class='table-entry'>let&nbsp;r&nbsp;=&nbsp;filter&nbsp;list:&nbsp;&lowbar;&nbsp;&gt;&nbsp;0&nbsp;</td><td class='table-entry'>var&nbsp;r&nbsp;=&nbsp;new&nbsp;List()&semi;<br />foreach&nbsp;(var&nbsp;x&nbsp;in&nbsp;list)&nbsp;if&nbsp;(x&nbsp;&gt;&nbsp;0)&nbsp;r.Add(x)&semi;&nbsp;</td><td></td></tr><tr><td class='table-entry'>let&nbsp;r&nbsp;=&nbsp;exists&nbsp;list:&nbsp;&lowbar;&nbsp;&gt;&nbsp;0&nbsp;</td><td class='table-entry'>var&nbsp;r&nbsp;=&nbsp;false&semi;<br />foreach&nbsp;(var&nbsp;x&nbsp;in&nbsp;list)&nbsp;if&nbsp;(x&nbsp;&gt;&nbsp;0)&nbsp;{&nbsp;r&nbsp;=&nbsp;true&semi;&nbsp;break&semi;&nbsp;}&nbsp;</td><td></td></tr></tbody></table><!-- doc table end --><!-- subheader start --><div class='subheader-section'><span>Functions & Scope</span></div><!-- subheader end --><!-- doc table start -->
<table class="table-doc" border="1" cellpadding="5" cellspacing="2"><tbody>
<tr>
<td class="table-header">Lobster Version</td>
<td class="table-header">C-style Version</td>
<td class="table-header">Notes</td>
</tr>
<tr><td class='table-entry'>def&nbsp;name(a:int,&nbsp;b:int)&nbsp;&dash;&gt;&nbsp;int:&nbsp;return&nbsp;a&nbsp;+&nbsp;b</td><td class='table-entry'>int&nbsp;name(int&nbsp;a,&nbsp;int&nbsp;b)&nbsp;{&nbsp;return&nbsp;a&nbsp;+&nbsp;b&semi;&nbsp;}</td><td>In Lobster, it's unusual to specify types, especially the function return type. Lobster infers types by default.</td></tr><tr><td class='table-entry'>def&nbsp;name(a,&nbsp;b):&nbsp;a&nbsp;+&nbsp;b&nbsp;</td><td class='table-entry'>T&nbsp;name&lt;T&gt;(T&nbsp;a,&nbsp;T&nbsp;b)&nbsp;{&nbsp;return&nbsp;a&nbsp;+&nbsp;b&semi;&nbsp;}</td><td>By default, functions are declared without types. The type is automatically inferred on use.</td></tr><tr><td class='table-entry'>def&nbsp;name(a,&nbsp;b):<br />&nbsp;&nbsp;a&nbsp;+&nbsp;b&nbsp;</td><td class='table-entry'>T&nbsp;name&lt;T&gt;(T&nbsp;a,&nbsp;T&nbsp;b)&nbsp;{<br />&nbsp;&nbsp;return&nbsp;a&nbsp;+&nbsp;b&semi;<br />}&nbsp;</td><td></td></tr><tr><td class='table-entry'>def&nbsp;magnitude(v::xy):&nbsp;sqrt(x&nbsp;*&nbsp;x&nbsp;+&nbsp;y&nbsp;*&nbsp;y)&nbsp;</td><td class='table-entry'>//&nbsp;inside&nbsp;class&nbsp;xy<br />float&nbsp;magnitude()&nbsp;{&nbsp;return&nbsp;x&nbsp;*&nbsp;x&nbsp;+&nbsp;y&nbsp;*&nbsp;y&semi;&nbsp;}&nbsp;</td><td>Using <code>::</code> indicates a type for the argument, allowing you to access an object's elements directly, rather than writing something like <code>object.x</code>. This is similar to writing a method, though Lobster makes no such distinction.</td></tr><tr><td class='table-entry'>//&nbsp;inside&nbsp;class/struct&nbsp;xy<br />def&nbsp;magnitude(v::xy):&nbsp;sqrt(x&nbsp;*&nbsp;x&nbsp;+&nbsp;y&nbsp;*&nbsp;y)&nbsp;</td><td class='table-entry'>//&nbsp;inside&nbsp;class&nbsp;xy<br />float&nbsp;magnitude()&nbsp;{&nbsp;return&nbsp;x&nbsp;*&nbsp;x&nbsp;+&nbsp;y&nbsp;*&nbsp;y&semi;&nbsp;}&nbsp;</td><td>This is an equivalent way of writing the above when inside the scope of a class or struct <em>(see below)</em>.</td></tr><tr><td class='table-entry'>v.magnitude()<br />magnitude(v)</td><td class='table-entry'>v.magnitude()&nbsp;</td><td>With function calls, you can move the first argument to the front of the call. This works for <em>any</em> function.</td></tr><tr><td class='table-entry'>def&nbsp;name(x:X,&nbsp;z:Z):&nbsp;0<br />def&nbsp;name(x:X,&nbsp;w:W):&nbsp;1<br />def&nbsp;name(x:Y,&nbsp;z:Z):&nbsp;2</td><td class='table-entry'>/*&nbsp;inside&nbsp;class&nbsp;X&nbsp;*/&nbsp;int&nbsp;name(B&nbsp;b)&nbsp;{&nbsp;return&nbsp;b.nameX()&semi;&nbsp;}<br />/*&nbsp;inside&nbsp;class&nbsp;Y&nbsp;*/&nbsp;int&nbsp;name(Z&nbsp;z)&nbsp;{&nbsp;return&nbsp;2&semi;&nbsp;}<br />/*&nbsp;inside&nbsp;class&nbsp;Z&nbsp;*/&nbsp;int&nbsp;nameX()&nbsp;{&nbsp;return&nbsp;0&semi;&nbsp;}<br />/*&nbsp;inside&nbsp;class&nbsp;W&nbsp;*/&nbsp;int&nbsp;nameX()&nbsp;{&nbsp;return&nbsp;1&semi;&nbsp;}&nbsp;</td><td>Polymorphic functions <em>(virtual methods, dynamic dispatch)</em> in Lobster are created simply by writing multiple functions. These functions can work on user defined types or built-in ones. They can also be written separate from where the type was defined.</td></tr><tr><td class='table-entry'>var&nbsp;f&nbsp;=&nbsp;def(a,&nbsp;b):&nbsp;a&nbsp;+&nbsp;b&nbsp;</td><td class='table-entry'>var&nbsp;f&nbsp;=&nbsp;(int&nbsp;a,&nbsp;int&nbsp;b)&nbsp;=&gt;&nbsp;a&nbsp;+&nbsp;b&nbsp;</td><td>Assigning a function to a variable compared to C#</td></tr><tr><td class='table-entry'>let&nbsp;f&nbsp;=&nbsp;def(a,&nbsp;b):&nbsp;a&nbsp;+&nbsp;b&nbsp;</td><td class='table-entry'>auto&nbsp;f&nbsp;=&nbsp;[](int&nbsp;a,&nbsp;int&nbsp;b)&nbsp;{&nbsp;return&nbsp;a&nbsp;+&nbsp;b&semi;&nbsp;}&nbsp;</td><td>Assigning a function to a variable compared to C++</td></tr><tr><td class='table-entry'>def&nbsp;fold(xs,&nbsp;init,&nbsp;fun):<br />&nbsp;&nbsp;for(xs):&nbsp;init&nbsp;=&nbsp;fun(init,&nbsp;&lowbar;)<br />&nbsp;&nbsp;init&nbsp;</td><td class='table-entry'>T&nbsp;fold&lt;T&gt;(List&lt;T&gt;&nbsp;xs,&nbsp;T&nbsp;init,&nbsp;Func&lt;T,&nbsp;T,&nbsp;T&gt;&nbsp;fun)&nbsp;{<br />&nbsp;&nbsp;foreach&nbsp;(var&nbsp;x&nbsp;in&nbsp;xs)&nbsp;init&nbsp;=&nbsp;fun(init,&nbsp;x)&semi;<br />&nbsp;&nbsp;return&nbsp;init&semi;<br />}&nbsp;</td><td><em>Higher Order Functions (i.e. functions that take a function as an argument)</em> in Lobster can be written like so. In this example, <code>fold</code> takes a list <code>xs</code> and applies the function <code>fun</code> to each element. Each iteration "folds" the list into a single value.</td></tr><tr><td class='table-entry'>let&nbsp;r&nbsp;=&nbsp;fold(list,&nbsp;0)&nbsp;x,&nbsp;y:&nbsp;x&nbsp;+&nbsp;y&nbsp;</td><td class='table-entry'>var&nbsp;r&nbsp;=&nbsp;fold(list,&nbsp;0,&nbsp;(x,&nbsp;y)&nbsp;=&gt;&nbsp;x&nbsp;+&nbsp;y)&semi;&nbsp;</td><td>Calling a function with a function value. Notice that <code>x</code> and <code>y</code> are the arguments of the function being passed into <code>fold</code>. This example sums all of the values in the list.</td></tr><tr><td class='table-entry'>let&nbsp;r&nbsp;=&nbsp;fold(list,&nbsp;0):&nbsp;&lowbar;a&nbsp;+&nbsp;&lowbar;b&nbsp;</td><td class='table-entry'>var&nbsp;r&nbsp;=&nbsp;fold(list,&nbsp;0,&nbsp;(a,&nbsp;b)&nbsp;=&gt;&nbsp;a&nbsp;+&nbsp;b)&semi;&nbsp;</td><td>Anonymous arguments in lexical order. <em>(see <a href="" target="_blank">Language Reference</a>)</em></td></tr><tr><td class='table-entry'>let&nbsp;r&nbsp;=&nbsp;fold(list,&nbsp;0)&nbsp;a,&nbsp;b:<br />&nbsp;&nbsp;print&nbsp;a<br />&nbsp;&nbsp;a&nbsp;+&nbsp;b&nbsp;</td><td class='table-entry'>var&nbsp;r&nbsp;=&nbsp;fold(list,&nbsp;0,&nbsp;(a,&nbsp;b)&nbsp;=&gt;&nbsp;{<br />&nbsp;&nbsp;print(a)&semi;<br />&nbsp;&nbsp;return&nbsp;a&nbsp;+&nbsp;b&semi;<br />})&semi;&nbsp;</td><td>In most other languages, lambda syntax becomes messy when used with larger bodies and looks different from the built-in control structures.</td></tr><tr><td class='table-entry'>let&nbsp;r&nbsp;=&nbsp;fold(list,&nbsp;0)&nbsp;a,&nbsp;b:<br />&nbsp;&nbsp;if&nbsp;a&nbsp;&lt;&nbsp;0:&nbsp;return&nbsp;a<br />&nbsp;&nbsp;a&nbsp;+&nbsp;b&nbsp;</td><td class='table-entry'>/*&nbsp;not&nbsp;possible&nbsp;*/&nbsp;</td><td>In most other languages, you cannot <code>return</code> or <code>break</code> inside lambdas, often making them useless as control structures. In Lobster, they're functionally consistent with the built-in control structures. By default, <code>return</code> returns from the lexically enclosing named function.</td></tr><tr><td class='table-entry'>def&nbsp;f():<br />&nbsp;&nbsp;g()<br />&nbsp;&nbsp;0<br />def&nbsp;g():<br />&nbsp;&nbsp;if&nbsp;something:&nbsp;return&nbsp;1&nbsp;from&nbsp;f<br />&nbsp;&nbsp;0</td><td class='table-entry'>int&nbsp;f()&nbsp;{<br />&nbsp;&nbsp;try&nbsp;{&nbsp;g()&semi;&nbsp;return&nbsp;0&semi;&nbsp;}<br />&nbsp;&nbsp;catch&nbsp;(int&nbsp;x)&nbsp;{&nbsp;return&nbsp;x&semi;&nbsp;}<br />}<br />int&nbsp;g()&nbsp;{<br />&nbsp;&nbsp;if&nbsp;(something)&nbsp;throw&nbsp;1&semi;<br />&nbsp;&nbsp;return&nbsp;0&semi;<br />}</td><td><code>return</code> also allows you to specify which function to return <code>from</code>. In other languages, you can do with exception handling. Exception handling in Lobster is actually not a language feature, it's a group of utility functions <em>(try, catch, etc.)</em> implemented on top of <code>return</code> and <code>from</code>.<br /></td></tr><tr><td class='table-entry'>def&nbsp;mret():&nbsp;return&nbsp;1,&nbsp;2&nbsp;</td><td class='table-entry'>int&nbsp;mret(out&nbsp;int&nbsp;o)&nbsp;{&nbsp;o&nbsp;=&nbsp;2&semi;&nbsp;return&nbsp;1&semi;&nbsp;}</td><td></td></tr><tr><td class='table-entry'>let&nbsp;a,&nbsp;b&nbsp;=&nbsp;mret()&nbsp;</td><td class='table-entry'>var&nbsp;b&semi;&nbsp;var&nbsp;a&nbsp;=&nbsp;mret(b)&semi;&nbsp;</td><td></td></tr></tbody></table><!-- doc table end --><!-- subheader start --><div class='subheader-section'><span>User-Defined Types</span></div><!-- subheader end --><!-- doc table start -->
<table class="table-doc" border="1" cellpadding="5" cellspacing="2"><tbody>
<tr>
<td class="table-header">Lobster Version</td>
<td class="table-header">C-style Version</td>
<td class="table-header">Notes</td>
</tr>
<tr><td class='table-entry'>struct&nbsp;xy&nbsp;{&nbsp;x:float,&nbsp;y:float&nbsp;}</td><td class='table-entry'>public&nbsp;struct&nbsp;xy&nbsp;{&nbsp;float&nbsp;x&semi;&nbsp;float&nbsp;y&semi;&nbsp;}</td><td></td></tr><tr><td class='table-entry'>struct&nbsp;xy&nbsp;{&nbsp;x,&nbsp;y&nbsp;}&nbsp;</td><td class='table-entry'>public&nbsp;struct&nbsp;xy&lt;T&gt;&nbsp;{&nbsp;T&nbsp;x&semi;&nbsp;T&nbsp;y&semi;&nbsp;}</td><td>Generics</td></tr><tr><td class='table-entry'>struct&nbsp;xyz:&nbsp;xy&nbsp;{&nbsp;z:float&nbsp;}&nbsp;</td><td class='table-entry'>public&nbsp;struct&nbsp;xyz&nbsp;:&nbsp;xy&nbsp;{&nbsp;float&nbsp;z&semi;&nbsp;}</td><td></td></tr><tr><td class='table-entry'>let&nbsp;v&nbsp;=&nbsp;xyz&nbsp;{&nbsp;1,&nbsp;0,&nbsp;0&nbsp;}&nbsp;</td><td class='table-entry'>var&nbsp;v&nbsp;=&nbsp;new&nbsp;xyz(1,&nbsp;0,&nbsp;0)&nbsp;</td><td>In C#, you'd have to define a constructor for this to work.</td></tr><tr><td class='table-entry'>struct&nbsp;xy:<br />&nbsp;&nbsp;x:float<br />&nbsp;&nbsp;y:float<br />&nbsp;&nbsp;def&nbsp;magnitude():<br />&nbsp;&nbsp;&nbsp;&nbsp;sqrt(x&nbsp;*&nbsp;x&nbsp;+&nbsp;y&nbsp;*&nbsp;y)&nbsp;</td><td class='table-entry'>public&nbsp;class&nbsp;xy&nbsp;{<br />&nbsp;&nbsp;float&nbsp;x&semi;<br />&nbsp;&nbsp;float&nbsp;y&semi;<br />&nbsp;&nbsp;float&nbsp;magnitude()&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;x&nbsp;*&nbsp;x&nbsp;+&nbsp;y&nbsp;*&nbsp;y&semi;<br />&nbsp;&nbsp;}<br />}</td><td>Indendation-based syntax with an inline function definition. <code>this</code> is inferred automatically.</td></tr></tbody></table><!-- doc table end --><!-- subheader start --><div class='subheader-section'><span>Coroutines</span></div><!-- subheader end --><!-- doc table start -->
<table class="table-doc" border="1" cellpadding="5" cellspacing="2"><tbody>
<tr>
<td class="table-header">Lobster Version</td>
<td class="table-header">C-style Version</td>
<td class="table-header">Notes</td>
</tr>
<tr><td class='table-entry'>def&nbsp;myiter(fun):<br />&nbsp;&nbsp;for(10)&nbsp;i:&nbsp;fun(i)&nbsp;</td><td class='table-entry'>IEnumerable&lt;T&gt;&nbsp;myiter()&nbsp;{<br />&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0&semi;&nbsp;i&nbsp;&lt;&nbsp;10&semi;&nbsp;i++)&nbsp;yield&nbsp;return&nbsp;i&semi;<br />}</td><td>In Lobster, Coroutines are defined like any other iteration function (by calling a function value). This allows you to easily define iteration functions without having to decide how you want to use them. In other languages, "yield return" can only be called from the <code>myiter</code> function body, not from any functions called from it. Lobster has no such limitations.</td></tr><tr><td class='table-entry'>let&nbsp;co&nbsp;=&nbsp;coroutine&nbsp;myiter()&nbsp;</td><td class='table-entry'>var&nbsp;co&nbsp;=&nbsp;myiter()&nbsp;</td><td></td></tr><tr><td class='table-entry'>co.return&lowbar;value&nbsp;</td><td class='table-entry'>co.Current&nbsp;</td><td>Getting the last value produced by a coroutine, or in Lobster's case, also the value returned at the end.</td></tr><tr><td class='table-entry'>co.resume&nbsp;</td><td class='table-entry'>co.MoveNext&nbsp;</td><td>Getting the next value from a coroutine.</td></tr><tr><td class='table-entry'>co.resume(x)&nbsp;</td><td class='table-entry'>/*&nbsp;not&nbsp;available&nbsp;*/&nbsp;</td><td>Getting a coroutine to produce the next value, returning <code>x</code> from the function call that yielded the coroutine last.</td></tr><tr><td class='table-entry'>var&nbsp;r&nbsp;=&nbsp;co.resume&nbsp;</td><td class='table-entry'>/*&nbsp;not&nbsp;available&nbsp;*/&nbsp;</td><td>Getting a coroutine to produce the next value, returning the argument to the function call.</td></tr><tr><td class='table-entry'>co.active&nbsp;</td><td class='table-entry'>/*&nbsp;not&nbsp;available&nbsp;*/&nbsp;</td><td>In C#, MoveNext returns a <code>boolean</code> value that is can be equivalent.</td></tr><tr><td class='table-entry'>co&dash;&gt;i&nbsp;</td><td class='table-entry'>/*&nbsp;not&nbsp;available&nbsp;*/&nbsp;</td><td>Accessing local variables inside a coroutine object. This features makes it easier for multiple coroutines to communicate.</td></tr></tbody></table><!-- doc table end --><!-- doc end --></body></html>